/*
 * Trace Server Protocol
 * Open source REST API for viewing and analyzing any type of logs or traces. Its goal is to provide models to populate views, graphs, metrics, and more to help extract useful information from traces, in a way that is more user-friendly and informative than huge text dumps.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: tracecompass-dev@eclipse.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.eclipse.tracecompass.incubator.tsp.client.core.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import org.eclipse.tracecompass.incubator.tsp.client.core.model.StyleValue;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import org.eclipse.tracecompass.incubator.tsp.client.core.JSON;


/**
 * Represents the style on an element (ex. Entry, TimeGraphState, ...) returned by any output. Supports style inheritance. To avoid having too many styles, the element style can have a parent style and will have all the same style property values as the parent, and can add or override style properties.
 */
@JsonPropertyOrder({
  OutputElementStyle.JSON_PROPERTY_PARENT_KEY,
  OutputElementStyle.JSON_PROPERTY_VALUES
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-09-19T10:33:13.979273368-04:00[America/Toronto]", comments = "Generator version: 7.15.0")
public class OutputElementStyle {
  public static final String JSON_PROPERTY_PARENT_KEY = "parentKey";
  @javax.annotation.Nullable
  private String parentKey;

  public static final String JSON_PROPERTY_VALUES = "values";
  @javax.annotation.Nonnull
  private Map<String, StyleValue> values = new HashMap<>();

  public OutputElementStyle() { 
  }

  public OutputElementStyle parentKey(@javax.annotation.Nullable String parentKey) {
    this.parentKey = parentKey;
    return this;
  }

  /**
   * Optional, parent style key. If omitted there is no parent. The parent key should match a style key defined in the style model and is used for style inheritance. A comma-delimited list of parent style keys can be used for style composition, the last one taking precedence.
   * @return parentKey
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PARENT_KEY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public String getParentKey() {
    return parentKey;
  }


  @JsonProperty(JSON_PROPERTY_PARENT_KEY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setParentKey(@javax.annotation.Nullable String parentKey) {
    this.parentKey = parentKey;
  }


  public OutputElementStyle values(@javax.annotation.Nonnull Map<String, StyleValue> values) {
    this.values = values;
    return this;
  }

  public OutputElementStyle putValuesItem(String key, StyleValue valuesItem) {
    if (this.values == null) {
      this.values = new HashMap<>();
    }
    this.values.put(key, valuesItem);
    return this;
  }

  /**
   * Style values or empty map if there are no values. Keys and values are defined in https://github.com/eclipse-tracecompass/org.eclipse.tracecompass/blob/master/tmf/org.eclipse.tracecompass.tmf.core/src/org/eclipse/tracecompass/tmf/core/model/StyleProperties.java
   * @return values
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_VALUES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Map<String, StyleValue> getValues() {
    return values;
  }


  @JsonProperty(JSON_PROPERTY_VALUES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setValues(@javax.annotation.Nonnull Map<String, StyleValue> values) {
    this.values = values;
  }


  /**
   * Return true if this OutputElementStyle object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    OutputElementStyle outputElementStyle = (OutputElementStyle) o;
    return Objects.equals(this.parentKey, outputElementStyle.parentKey) &&
        Objects.equals(this.values, outputElementStyle.values);
  }

  @Override
  public int hashCode() {
    return Objects.hash(parentKey, values);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class OutputElementStyle {\n");
    sb.append("    parentKey: ").append(toIndentedString(parentKey)).append("\n");
    sb.append("    values: ").append(toIndentedString(values)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

