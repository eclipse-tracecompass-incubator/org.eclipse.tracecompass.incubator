/*
 * Trace Server Protocol
 * Open source REST API for viewing and analyzing any type of logs or traces. Its goal is to provide models to populate views, graphs, metrics, and more to help extract useful information from traces, in a way that is more user-friendly and informative than huge text dumps.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: tracecompass-dev@eclipse.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.eclipse.tracecompass.incubator.tsp.client.core.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.eclipse.tracecompass.incubator.tsp.client.core.model.OutputElementStyle;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import org.eclipse.tracecompass.incubator.tsp.client.core.JSON;


/**
 * Base entry returned by tree endpoints
 */
@JsonPropertyOrder({
  TreeDataModel.JSON_PROPERTY_HAS_DATA,
  TreeDataModel.JSON_PROPERTY_PARENT_ID,
  TreeDataModel.JSON_PROPERTY_STYLE,
  TreeDataModel.JSON_PROPERTY_ID,
  TreeDataModel.JSON_PROPERTY_LABELS
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-09-19T10:33:13.979273368-04:00[America/Toronto]", comments = "Generator version: 7.15.0")
public class TreeDataModel {
  public static final String JSON_PROPERTY_HAS_DATA = "hasData";
  @javax.annotation.Nullable
  private Boolean hasData;

  public static final String JSON_PROPERTY_PARENT_ID = "parentId";
  @javax.annotation.Nullable
  private Long parentId;

  public static final String JSON_PROPERTY_STYLE = "style";
  @javax.annotation.Nullable
  private OutputElementStyle style;

  public static final String JSON_PROPERTY_ID = "id";
  @javax.annotation.Nonnull
  private Long id;

  public static final String JSON_PROPERTY_LABELS = "labels";
  @javax.annotation.Nonnull
  private List<String> labels = new ArrayList<>();

  public TreeDataModel() { 
  }

  public TreeDataModel hasData(@javax.annotation.Nullable Boolean hasData) {
    this.hasData = hasData;
    return this;
  }

  /**
   * Whether or not this entry has data. false if absent.
   * @return hasData
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_HAS_DATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getHasData() {
    return hasData;
  }


  @JsonProperty(JSON_PROPERTY_HAS_DATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setHasData(@javax.annotation.Nullable Boolean hasData) {
    this.hasData = hasData;
  }


  public TreeDataModel parentId(@javax.annotation.Nullable Long parentId) {
    this.parentId = parentId;
    return this;
  }

  /**
   * Optional unique ID to identify this entry&#39;s parent. If the parent ID is -1 or omitted, this entry has no parent.
   * @return parentId
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PARENT_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Long getParentId() {
    return parentId;
  }


  @JsonProperty(JSON_PROPERTY_PARENT_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setParentId(@javax.annotation.Nullable Long parentId) {
    this.parentId = parentId;
  }


  public TreeDataModel style(@javax.annotation.Nullable OutputElementStyle style) {
    this.style = style;
    return this;
  }

  /**
   * Get style
   * @return style
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STYLE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public OutputElementStyle getStyle() {
    return style;
  }


  @JsonProperty(JSON_PROPERTY_STYLE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStyle(@javax.annotation.Nullable OutputElementStyle style) {
    this.style = style;
  }


  public TreeDataModel id(@javax.annotation.Nonnull Long id) {
    this.id = id;
    return this;
  }

  /**
   * Unique ID to identify this entry in the backend
   * @return id
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Long getId() {
    return id;
  }


  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setId(@javax.annotation.Nonnull Long id) {
    this.id = id;
  }


  public TreeDataModel labels(@javax.annotation.Nonnull List<String> labels) {
    this.labels = labels;
    return this;
  }

  public TreeDataModel addLabelsItem(String labelsItem) {
    if (this.labels == null) {
      this.labels = new ArrayList<>();
    }
    this.labels.add(labelsItem);
    return this;
  }

  /**
   * Array of cell labels to be displayed. The length of the array and the index of each column need to correspond to the header array returned in the tree model.
   * @return labels
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LABELS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<String> getLabels() {
    return labels;
  }


  @JsonProperty(JSON_PROPERTY_LABELS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLabels(@javax.annotation.Nonnull List<String> labels) {
    this.labels = labels;
  }


  /**
   * Return true if this TreeDataModel object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TreeDataModel treeDataModel = (TreeDataModel) o;
    return Objects.equals(this.hasData, treeDataModel.hasData) &&
        Objects.equals(this.parentId, treeDataModel.parentId) &&
        Objects.equals(this.style, treeDataModel.style) &&
        Objects.equals(this.id, treeDataModel.id) &&
        Objects.equals(this.labels, treeDataModel.labels);
  }

  @Override
  public int hashCode() {
    return Objects.hash(hasData, parentId, style, id, labels);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TreeDataModel {\n");
    sb.append("    hasData: ").append(toIndentedString(hasData)).append("\n");
    sb.append("    parentId: ").append(toIndentedString(parentId)).append("\n");
    sb.append("    style: ").append(toIndentedString(style)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

