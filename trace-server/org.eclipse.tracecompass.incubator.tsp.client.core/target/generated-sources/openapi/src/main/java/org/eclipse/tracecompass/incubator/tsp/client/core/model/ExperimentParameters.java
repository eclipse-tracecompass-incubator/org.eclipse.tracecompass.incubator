/*
 * Trace Server Protocol
 * Open source REST API for viewing and analyzing any type of logs or traces. Its goal is to provide models to populate views, graphs, metrics, and more to help extract useful information from traces, in a way that is more user-friendly and informative than huge text dumps.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: tracecompass-dev@eclipse.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.eclipse.tracecompass.incubator.tsp.client.core.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.UUID;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import org.eclipse.tracecompass.incubator.tsp.client.core.JSON;


/**
 * ExperimentParameters
 */
@JsonPropertyOrder({
  ExperimentParameters.JSON_PROPERTY_TRACES,
  ExperimentParameters.JSON_PROPERTY_NAME
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-09-19T10:33:13.979273368-04:00[America/Toronto]", comments = "Generator version: 7.15.0")
public class ExperimentParameters {
  public static final String JSON_PROPERTY_TRACES = "traces";
  @javax.annotation.Nonnull
  private List<UUID> traces = new ArrayList<>();

  public static final String JSON_PROPERTY_NAME = "name";
  @javax.annotation.Nonnull
  private String name;

  public ExperimentParameters() { 
  }

  public ExperimentParameters traces(@javax.annotation.Nonnull List<UUID> traces) {
    this.traces = traces;
    return this;
  }

  public ExperimentParameters addTracesItem(UUID tracesItem) {
    if (this.traces == null) {
      this.traces = new ArrayList<>();
    }
    this.traces.add(tracesItem);
    return this;
  }

  /**
   * The unique identifiers of the traces to encapsulate in this experiment
   * @return traces
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_TRACES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<UUID> getTraces() {
    return traces;
  }


  @JsonProperty(JSON_PROPERTY_TRACES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTraces(@javax.annotation.Nonnull List<UUID> traces) {
    this.traces = traces;
  }


  public ExperimentParameters name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * The name to give this experiment
   * @return name
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  /**
   * Return true if this ExperimentParameters object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ExperimentParameters experimentParameters = (ExperimentParameters) o;
    return Objects.equals(this.traces, experimentParameters.traces) &&
        Objects.equals(this.name, experimentParameters.name);
  }

  @Override
  public int hashCode() {
    return Objects.hash(traces, name);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ExperimentParameters {\n");
    sb.append("    traces: ").append(toIndentedString(traces)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

