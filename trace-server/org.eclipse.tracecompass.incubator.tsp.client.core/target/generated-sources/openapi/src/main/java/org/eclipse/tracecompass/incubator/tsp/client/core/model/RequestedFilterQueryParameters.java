/*
 * Trace Server Protocol
 * Open source REST API for viewing and analyzing any type of logs or traces. Its goal is to provide models to populate views, graphs, metrics, and more to help extract useful information from traces, in a way that is more user-friendly and informative than huge text dumps.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: tracecompass-dev@eclipse.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.eclipse.tracecompass.incubator.tsp.client.core.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import org.eclipse.tracecompass.incubator.tsp.client.core.JSON;


/**
 * FilterQueryParameters is used to support search and filter expressions for timegraph views
 */
@JsonPropertyOrder({
  RequestedFilterQueryParameters.JSON_PROPERTY_FILTER_EXPRESSIONS_MAP,
  RequestedFilterQueryParameters.JSON_PROPERTY_STRATEGY
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-09-19T10:33:13.979273368-04:00[America/Toronto]", comments = "Generator version: 7.15.0")
public class RequestedFilterQueryParameters {
  public static final String JSON_PROPERTY_FILTER_EXPRESSIONS_MAP = "filter_expressions_map";
  @javax.annotation.Nonnull
  private Map<String, List<String>> filterExpressionsMap = new HashMap<>();

  /**
   * Optional parameter that enables the full search (deep search) or not
   */
  public enum StrategyEnum {
    SAMPLED(String.valueOf("SAMPLED")),
    
    DEEP(String.valueOf("DEEP"));

    private String value;

    StrategyEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static StrategyEnum fromValue(String value) {
      for (StrategyEnum b : StrategyEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_STRATEGY = "strategy";
  @javax.annotation.Nullable
  private StrategyEnum strategy;

  public RequestedFilterQueryParameters() { 
  }

  public RequestedFilterQueryParameters filterExpressionsMap(@javax.annotation.Nonnull Map<String, List<String>> filterExpressionsMap) {
    this.filterExpressionsMap = filterExpressionsMap;
    return this;
  }

  public RequestedFilterQueryParameters putFilterExpressionsMapItem(String key, List<String> filterExpressionsMapItem) {
    if (this.filterExpressionsMap == null) {
      this.filterExpressionsMap = new HashMap<>();
    }
    this.filterExpressionsMap.put(key, filterExpressionsMapItem);
    return this;
  }

  /**
   * The key of this map can be \&quot;1\&quot; (means DIMMED) or \&quot;4\&quot; (means EXCLUDED) and the value is an array of the desired search query (e.g. {\&quot;1\&quot;: [\&quot;openat\&quot;, \&quot;duration&gt;10ms\&quot;]})
   * @return filterExpressionsMap
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_FILTER_EXPRESSIONS_MAP)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Map<String, List<String>> getFilterExpressionsMap() {
    return filterExpressionsMap;
  }


  @JsonProperty(JSON_PROPERTY_FILTER_EXPRESSIONS_MAP)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setFilterExpressionsMap(@javax.annotation.Nonnull Map<String, List<String>> filterExpressionsMap) {
    this.filterExpressionsMap = filterExpressionsMap;
  }


  public RequestedFilterQueryParameters strategy(@javax.annotation.Nullable StrategyEnum strategy) {
    this.strategy = strategy;
    return this;
  }

  /**
   * Optional parameter that enables the full search (deep search) or not
   * @return strategy
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STRATEGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public StrategyEnum getStrategy() {
    return strategy;
  }


  @JsonProperty(JSON_PROPERTY_STRATEGY)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStrategy(@javax.annotation.Nullable StrategyEnum strategy) {
    this.strategy = strategy;
  }


  /**
   * Return true if this RequestedFilterQueryParameters object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    RequestedFilterQueryParameters requestedFilterQueryParameters = (RequestedFilterQueryParameters) o;
    return Objects.equals(this.filterExpressionsMap, requestedFilterQueryParameters.filterExpressionsMap) &&
        Objects.equals(this.strategy, requestedFilterQueryParameters.strategy);
  }

  @Override
  public int hashCode() {
    return Objects.hash(filterExpressionsMap, strategy);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class RequestedFilterQueryParameters {\n");
    sb.append("    filterExpressionsMap: ").append(toIndentedString(filterExpressionsMap)).append("\n");
    sb.append("    strategy: ").append(toIndentedString(strategy)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

