/*
 * Trace Server Protocol
 * Open source REST API for viewing and analyzing any type of logs or traces. Its goal is to provide models to populate views, graphs, metrics, and more to help extract useful information from traces, in a way that is more user-friendly and informative than huge text dumps.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: tracecompass-dev@eclipse.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.eclipse.tracecompass.incubator.tsp.client.core.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.eclipse.tracecompass.incubator.tsp.client.core.model.VirtualTableLine;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import org.eclipse.tracecompass.incubator.tsp.client.core.JSON;


/**
 * VirtualTableModel
 */
@JsonPropertyOrder({
  VirtualTableModel.JSON_PROPERTY_COLUMN_IDS,
  VirtualTableModel.JSON_PROPERTY_LOW_INDEX,
  VirtualTableModel.JSON_PROPERTY_LINES,
  VirtualTableModel.JSON_PROPERTY_SIZE
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-09-19T10:33:13.979273368-04:00[America/Toronto]", comments = "Generator version: 7.15.0")
public class VirtualTableModel {
  public static final String JSON_PROPERTY_COLUMN_IDS = "columnIds";
  @javax.annotation.Nonnull
  private List<Long> columnIds = new ArrayList<>();

  public static final String JSON_PROPERTY_LOW_INDEX = "lowIndex";
  @javax.annotation.Nonnull
  private Long lowIndex;

  public static final String JSON_PROPERTY_LINES = "lines";
  @javax.annotation.Nonnull
  private List<VirtualTableLine> lines = new ArrayList<>();

  public static final String JSON_PROPERTY_SIZE = "size";
  @javax.annotation.Nonnull
  private Long size;

  public VirtualTableModel() { 
  }

  public VirtualTableModel columnIds(@javax.annotation.Nonnull List<Long> columnIds) {
    this.columnIds = columnIds;
    return this;
  }

  public VirtualTableModel addColumnIdsItem(Long columnIdsItem) {
    if (this.columnIds == null) {
      this.columnIds = new ArrayList<>();
    }
    this.columnIds.add(columnIdsItem);
    return this;
  }

  /**
   * The array of column ids that are returned. They should match the content of the lines&#39; content
   * @return columnIds
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_COLUMN_IDS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<Long> getColumnIds() {
    return columnIds;
  }


  @JsonProperty(JSON_PROPERTY_COLUMN_IDS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setColumnIds(@javax.annotation.Nonnull List<Long> columnIds) {
    this.columnIds = columnIds;
  }


  public VirtualTableModel lowIndex(@javax.annotation.Nonnull Long lowIndex) {
    this.lowIndex = lowIndex;
    return this;
  }

  /**
   * Index in the virtual table of the first returned event
   * @return lowIndex
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LOW_INDEX)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Long getLowIndex() {
    return lowIndex;
  }


  @JsonProperty(JSON_PROPERTY_LOW_INDEX)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLowIndex(@javax.annotation.Nonnull Long lowIndex) {
    this.lowIndex = lowIndex;
  }


  public VirtualTableModel lines(@javax.annotation.Nonnull List<VirtualTableLine> lines) {
    this.lines = lines;
    return this;
  }

  public VirtualTableModel addLinesItem(VirtualTableLine linesItem) {
    if (this.lines == null) {
      this.lines = new ArrayList<>();
    }
    this.lines.add(linesItem);
    return this;
  }

  /**
   * Get lines
   * @return lines
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LINES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<VirtualTableLine> getLines() {
    return lines;
  }


  @JsonProperty(JSON_PROPERTY_LINES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLines(@javax.annotation.Nonnull List<VirtualTableLine> lines) {
    this.lines = lines;
  }


  public VirtualTableModel size(@javax.annotation.Nonnull Long size) {
    this.size = size;
    return this;
  }

  /**
   * Number of events. If filtered, the size will be the number of events that match the filters
   * @return size
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_SIZE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Long getSize() {
    return size;
  }


  @JsonProperty(JSON_PROPERTY_SIZE)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSize(@javax.annotation.Nonnull Long size) {
    this.size = size;
  }


  /**
   * Return true if this VirtualTableModel object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    VirtualTableModel virtualTableModel = (VirtualTableModel) o;
    return Objects.equals(this.columnIds, virtualTableModel.columnIds) &&
        Objects.equals(this.lowIndex, virtualTableModel.lowIndex) &&
        Objects.equals(this.lines, virtualTableModel.lines) &&
        Objects.equals(this.size, virtualTableModel.size);
  }

  @Override
  public int hashCode() {
    return Objects.hash(columnIds, lowIndex, lines, size);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class VirtualTableModel {\n");
    sb.append("    columnIds: ").append(toIndentedString(columnIds)).append("\n");
    sb.append("    lowIndex: ").append(toIndentedString(lowIndex)).append("\n");
    sb.append("    lines: ").append(toIndentedString(lines)).append("\n");
    sb.append("    size: ").append(toIndentedString(size)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

