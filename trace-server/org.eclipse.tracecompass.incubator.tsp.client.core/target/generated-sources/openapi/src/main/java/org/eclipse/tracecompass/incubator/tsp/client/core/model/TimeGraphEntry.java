/*
 * Trace Server Protocol
 * Open source REST API for viewing and analyzing any type of logs or traces. Its goal is to provide models to populate views, graphs, metrics, and more to help extract useful information from traces, in a way that is more user-friendly and informative than huge text dumps.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: tracecompass-dev@eclipse.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.eclipse.tracecompass.incubator.tsp.client.core.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import org.eclipse.tracecompass.incubator.tsp.client.core.model.MetadataValue;
import org.eclipse.tracecompass.incubator.tsp.client.core.model.OutputElementStyle;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import org.eclipse.tracecompass.incubator.tsp.client.core.JSON;


/**
 * TimeGraphEntry
 */
@JsonPropertyOrder({
  TimeGraphEntry.JSON_PROPERTY_HAS_DATA,
  TimeGraphEntry.JSON_PROPERTY_PARENT_ID,
  TimeGraphEntry.JSON_PROPERTY_STYLE,
  TimeGraphEntry.JSON_PROPERTY_ID,
  TimeGraphEntry.JSON_PROPERTY_LABELS,
  TimeGraphEntry.JSON_PROPERTY_END,
  TimeGraphEntry.JSON_PROPERTY_METADATA,
  TimeGraphEntry.JSON_PROPERTY_START
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-09-19T10:33:13.979273368-04:00[America/Toronto]", comments = "Generator version: 7.15.0")
public class TimeGraphEntry {
  public static final String JSON_PROPERTY_HAS_DATA = "hasData";
  @javax.annotation.Nullable
  private Boolean hasData;

  public static final String JSON_PROPERTY_PARENT_ID = "parentId";
  @javax.annotation.Nullable
  private Long parentId;

  public static final String JSON_PROPERTY_STYLE = "style";
  @javax.annotation.Nullable
  private OutputElementStyle style;

  public static final String JSON_PROPERTY_ID = "id";
  @javax.annotation.Nonnull
  private Long id;

  public static final String JSON_PROPERTY_LABELS = "labels";
  @javax.annotation.Nonnull
  private List<String> labels = new ArrayList<>();

  public static final String JSON_PROPERTY_END = "end";
  @javax.annotation.Nonnull
  private Long end;

  public static final String JSON_PROPERTY_METADATA = "metadata";
  @javax.annotation.Nullable
  private Map<String, List<MetadataValue>> metadata = new HashMap<>();

  public static final String JSON_PROPERTY_START = "start";
  @javax.annotation.Nonnull
  private Long start;

  public TimeGraphEntry() { 
  }

  public TimeGraphEntry hasData(@javax.annotation.Nullable Boolean hasData) {
    this.hasData = hasData;
    return this;
  }

  /**
   * Whether or not this entry has data. false if absent.
   * @return hasData
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_HAS_DATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Boolean getHasData() {
    return hasData;
  }


  @JsonProperty(JSON_PROPERTY_HAS_DATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setHasData(@javax.annotation.Nullable Boolean hasData) {
    this.hasData = hasData;
  }


  public TimeGraphEntry parentId(@javax.annotation.Nullable Long parentId) {
    this.parentId = parentId;
    return this;
  }

  /**
   * Optional unique ID to identify this entry&#39;s parent. If the parent ID is -1 or omitted, this entry has no parent.
   * @return parentId
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_PARENT_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Long getParentId() {
    return parentId;
  }


  @JsonProperty(JSON_PROPERTY_PARENT_ID)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setParentId(@javax.annotation.Nullable Long parentId) {
    this.parentId = parentId;
  }


  public TimeGraphEntry style(@javax.annotation.Nullable OutputElementStyle style) {
    this.style = style;
    return this;
  }

  /**
   * Get style
   * @return style
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_STYLE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public OutputElementStyle getStyle() {
    return style;
  }


  @JsonProperty(JSON_PROPERTY_STYLE)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setStyle(@javax.annotation.Nullable OutputElementStyle style) {
    this.style = style;
  }


  public TimeGraphEntry id(@javax.annotation.Nonnull Long id) {
    this.id = id;
    return this;
  }

  /**
   * Unique ID to identify this entry in the backend
   * @return id
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Long getId() {
    return id;
  }


  @JsonProperty(JSON_PROPERTY_ID)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setId(@javax.annotation.Nonnull Long id) {
    this.id = id;
  }


  public TimeGraphEntry labels(@javax.annotation.Nonnull List<String> labels) {
    this.labels = labels;
    return this;
  }

  public TimeGraphEntry addLabelsItem(String labelsItem) {
    if (this.labels == null) {
      this.labels = new ArrayList<>();
    }
    this.labels.add(labelsItem);
    return this;
  }

  /**
   * Array of cell labels to be displayed. The length of the array and the index of each column need to correspond to the header array returned in the tree model.
   * @return labels
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_LABELS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public List<String> getLabels() {
    return labels;
  }


  @JsonProperty(JSON_PROPERTY_LABELS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLabels(@javax.annotation.Nonnull List<String> labels) {
    this.labels = labels;
  }


  public TimeGraphEntry end(@javax.annotation.Nonnull Long end) {
    this.end = end;
    return this;
  }

  /**
   * End of the range for which this entry exists
   * @return end
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_END)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Long getEnd() {
    return end;
  }


  @JsonProperty(JSON_PROPERTY_END)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setEnd(@javax.annotation.Nonnull Long end) {
    this.end = end;
  }


  public TimeGraphEntry metadata(@javax.annotation.Nullable Map<String, List<MetadataValue>> metadata) {
    this.metadata = metadata;
    return this;
  }

  public TimeGraphEntry putMetadataItem(String key, List<MetadataValue> metadataItem) {
    if (this.metadata == null) {
      this.metadata = new HashMap<>();
    }
    this.metadata.put(key, metadataItem);
    return this;
  }

  /**
   * Optional metadata map for domain specific data for matching data across data providers. Keys for the same data shall be the same across data providers. For each key all values shall have the same type.
   * @return metadata
   */
  @javax.annotation.Nullable
  @JsonProperty(JSON_PROPERTY_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)

  public Map<String, List<MetadataValue>> getMetadata() {
    return metadata;
  }


  @JsonProperty(JSON_PROPERTY_METADATA)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setMetadata(@javax.annotation.Nullable Map<String, List<MetadataValue>> metadata) {
    this.metadata = metadata;
  }


  public TimeGraphEntry start(@javax.annotation.Nonnull Long start) {
    this.start = start;
    return this;
  }

  /**
   * Beginning of the range for which this entry exists
   * @return start
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_START)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Long getStart() {
    return start;
  }


  @JsonProperty(JSON_PROPERTY_START)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setStart(@javax.annotation.Nonnull Long start) {
    this.start = start;
  }


  /**
   * Return true if this TimeGraphEntry object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    TimeGraphEntry timeGraphEntry = (TimeGraphEntry) o;
    return Objects.equals(this.hasData, timeGraphEntry.hasData) &&
        Objects.equals(this.parentId, timeGraphEntry.parentId) &&
        Objects.equals(this.style, timeGraphEntry.style) &&
        Objects.equals(this.id, timeGraphEntry.id) &&
        Objects.equals(this.labels, timeGraphEntry.labels) &&
        Objects.equals(this.end, timeGraphEntry.end) &&
        Objects.equals(this.metadata, timeGraphEntry.metadata) &&
        Objects.equals(this.start, timeGraphEntry.start);
  }

  @Override
  public int hashCode() {
    return Objects.hash(hasData, parentId, style, id, labels, end, metadata, start);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class TimeGraphEntry {\n");
    sb.append("    hasData: ").append(toIndentedString(hasData)).append("\n");
    sb.append("    parentId: ").append(toIndentedString(parentId)).append("\n");
    sb.append("    style: ").append(toIndentedString(style)).append("\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    labels: ").append(toIndentedString(labels)).append("\n");
    sb.append("    end: ").append(toIndentedString(end)).append("\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    start: ").append(toIndentedString(start)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

