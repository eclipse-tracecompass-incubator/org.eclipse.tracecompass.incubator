/*
 * Trace Server Protocol
 * Open source REST API for viewing and analyzing any type of logs or traces. Its goal is to provide models to populate views, graphs, metrics, and more to help extract useful information from traces, in a way that is more user-friendly and informative than huge text dumps.
 *
 * The version of the OpenAPI document: 0.5.0
 * Contact: tracecompass-dev@eclipse.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.eclipse.tracecompass.incubator.tsp.client.core.model;

import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import org.eclipse.tracecompass.incubator.tsp.client.core.JSON;


/**
 * Trace model
 */
@JsonPropertyOrder({
  Trace.JSON_PROPERTY_END,
  Trace.JSON_PROPERTY_NB_EVENTS,
  Trace.JSON_PROPERTY_INDEXING_STATUS,
  Trace.JSON_PROPERTY_NAME,
  Trace.JSON_PROPERTY_PROPERTIES,
  Trace.JSON_PROPERTY_PATH,
  Trace.JSON_PROPERTY_START,
  Trace.JSON_PROPERTY_U_U_I_D
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-09-19T10:33:13.979273368-04:00[America/Toronto]", comments = "Generator version: 7.15.0")
public class Trace {
  public static final String JSON_PROPERTY_END = "end";
  @javax.annotation.Nonnull
  private Long end;

  public static final String JSON_PROPERTY_NB_EVENTS = "nbEvents";
  @javax.annotation.Nonnull
  private Long nbEvents;

  /**
   * Status of the trace indexing
   */
  public enum IndexingStatusEnum {
    RUNNING(String.valueOf("RUNNING")),
    
    COMPLETED(String.valueOf("COMPLETED")),
    
    CLOSED(String.valueOf("CLOSED"));

    private String value;

    IndexingStatusEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static IndexingStatusEnum fromValue(String value) {
      for (IndexingStatusEnum b : IndexingStatusEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_INDEXING_STATUS = "indexingStatus";
  @javax.annotation.Nonnull
  private IndexingStatusEnum indexingStatus;

  public static final String JSON_PROPERTY_NAME = "name";
  @javax.annotation.Nonnull
  private String name;

  public static final String JSON_PROPERTY_PROPERTIES = "properties";
  @javax.annotation.Nonnull
  private Map<String, String> properties = new HashMap<>();

  public static final String JSON_PROPERTY_PATH = "path";
  @javax.annotation.Nonnull
  private String path;

  public static final String JSON_PROPERTY_START = "start";
  @javax.annotation.Nonnull
  private Long start;

  public static final String JSON_PROPERTY_U_U_I_D = "UUID";
  @javax.annotation.Nonnull
  private UUID uuid;

  public Trace() { 
  }

  public Trace end(@javax.annotation.Nonnull Long end) {
    this.end = end;
    return this;
  }

  /**
   * The trace&#39;s end time
   * @return end
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_END)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Long getEnd() {
    return end;
  }


  @JsonProperty(JSON_PROPERTY_END)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setEnd(@javax.annotation.Nonnull Long end) {
    this.end = end;
  }


  public Trace nbEvents(@javax.annotation.Nonnull Long nbEvents) {
    this.nbEvents = nbEvents;
    return this;
  }

  /**
   * Current number of indexed events in the trace
   * @return nbEvents
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_NB_EVENTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Long getNbEvents() {
    return nbEvents;
  }


  @JsonProperty(JSON_PROPERTY_NB_EVENTS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setNbEvents(@javax.annotation.Nonnull Long nbEvents) {
    this.nbEvents = nbEvents;
  }


  public Trace indexingStatus(@javax.annotation.Nonnull IndexingStatusEnum indexingStatus) {
    this.indexingStatus = indexingStatus;
    return this;
  }

  /**
   * Status of the trace indexing
   * @return indexingStatus
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_INDEXING_STATUS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public IndexingStatusEnum getIndexingStatus() {
    return indexingStatus;
  }


  @JsonProperty(JSON_PROPERTY_INDEXING_STATUS)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setIndexingStatus(@javax.annotation.Nonnull IndexingStatusEnum indexingStatus) {
    this.indexingStatus = indexingStatus;
  }


  public Trace name(@javax.annotation.Nonnull String name) {
    this.name = name;
    return this;
  }

  /**
   * User defined name for the trace
   * @return name
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getName() {
    return name;
  }


  @JsonProperty(JSON_PROPERTY_NAME)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setName(@javax.annotation.Nonnull String name) {
    this.name = name;
  }


  public Trace properties(@javax.annotation.Nonnull Map<String, String> properties) {
    this.properties = properties;
    return this;
  }

  public Trace putPropertiesItem(String key, String propertiesItem) {
    if (this.properties == null) {
      this.properties = new HashMap<>();
    }
    this.properties.put(key, propertiesItem);
    return this;
  }

  /**
   * The trace&#39;s properties
   * @return properties
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_PROPERTIES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Map<String, String> getProperties() {
    return properties;
  }


  @JsonProperty(JSON_PROPERTY_PROPERTIES)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setProperties(@javax.annotation.Nonnull Map<String, String> properties) {
    this.properties = properties;
  }


  public Trace path(@javax.annotation.Nonnull String path) {
    this.path = path;
    return this;
  }

  /**
   * Path to the trace on the server&#39;s file system
   * @return path
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_PATH)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public String getPath() {
    return path;
  }


  @JsonProperty(JSON_PROPERTY_PATH)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setPath(@javax.annotation.Nonnull String path) {
    this.path = path;
  }


  public Trace start(@javax.annotation.Nonnull Long start) {
    this.start = start;
    return this;
  }

  /**
   * The trace&#39;s start time
   * @return start
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_START)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public Long getStart() {
    return start;
  }


  @JsonProperty(JSON_PROPERTY_START)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setStart(@javax.annotation.Nonnull Long start) {
    this.start = start;
  }


  public Trace uuid(@javax.annotation.Nonnull UUID uuid) {
    this.uuid = uuid;
    return this;
  }

  /**
   * The trace&#39;s unique identifier
   * @return uuid
   */
  @javax.annotation.Nonnull
  @JsonProperty(JSON_PROPERTY_U_U_I_D)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)

  public UUID getUUID() {
    return uuid;
  }


  @JsonProperty(JSON_PROPERTY_U_U_I_D)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setUUID(@javax.annotation.Nonnull UUID uuid) {
    this.uuid = uuid;
  }


  /**
   * Return true if this Trace object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Trace trace = (Trace) o;
    return Objects.equals(this.end, trace.end) &&
        Objects.equals(this.nbEvents, trace.nbEvents) &&
        Objects.equals(this.indexingStatus, trace.indexingStatus) &&
        Objects.equals(this.name, trace.name) &&
        Objects.equals(this.properties, trace.properties) &&
        Objects.equals(this.path, trace.path) &&
        Objects.equals(this.start, trace.start) &&
        Objects.equals(this.uuid, trace.uuid);
  }

  @Override
  public int hashCode() {
    return Objects.hash(end, nbEvents, indexingStatus, name, properties, path, start, uuid);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Trace {\n");
    sb.append("    end: ").append(toIndentedString(end)).append("\n");
    sb.append("    nbEvents: ").append(toIndentedString(nbEvents)).append("\n");
    sb.append("    indexingStatus: ").append(toIndentedString(indexingStatus)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    properties: ").append(toIndentedString(properties)).append("\n");
    sb.append("    path: ").append(toIndentedString(path)).append("\n");
    sb.append("    start: ").append(toIndentedString(start)).append("\n");
    sb.append("    uuid: ").append(toIndentedString(uuid)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

