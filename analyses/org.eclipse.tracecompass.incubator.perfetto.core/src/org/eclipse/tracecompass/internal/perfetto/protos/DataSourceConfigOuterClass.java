// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: protos/perfetto/config/data_source_config.proto
// Protobuf Java Version: 4.29.3

package org.eclipse.tracecompass.incubator.internal.perfetto.protos;

public final class DataSourceConfigOuterClass {
  private DataSourceConfigOuterClass() {}
  static {
    com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
      com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
      /* major= */ 4,
      /* minor= */ 29,
      /* patch= */ 3,
      /* suffix= */ "",
      DataSourceConfigOuterClass.class.getName());
  }
  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistryLite registry) {
  }

  public static void registerAllExtensions(
      com.google.protobuf.ExtensionRegistry registry) {
    registerAllExtensions(
        (com.google.protobuf.ExtensionRegistryLite) registry);
  }
  public interface DataSourceConfigOrBuilder extends
      // @@protoc_insertion_point(interface_extends:perfetto.protos.DataSourceConfig)
      com.google.protobuf.MessageOrBuilder {

    /**
     * <pre>
     * Data source unique name, e.g., "linux.ftrace". This must match
     * the name passed by the data source when it registers (see
     * RegisterDataSource()).
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    boolean hasName();
    /**
     * <pre>
     * Data source unique name, e.g., "linux.ftrace". This must match
     * the name passed by the data source when it registers (see
     * RegisterDataSource()).
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    java.lang.String getName();
    /**
     * <pre>
     * Data source unique name, e.g., "linux.ftrace". This must match
     * the name passed by the data source when it registers (see
     * RegisterDataSource()).
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    com.google.protobuf.ByteString
        getNameBytes();

    /**
     * <pre>
     * The index of the logging buffer where TracePacket(s) will be stored.
     * This field doesn't make a major difference for the Producer(s). The final
     * logging buffers, in fact, are completely owned by the Service. We just ask
     * the Producer to copy this number into the chunk headers it emits, so that
     * the Service can quickly identify the buffer where to move the chunks into
     * without expensive lookups on its fastpath.
     * </pre>
     *
     * <code>optional uint32 target_buffer = 2;</code>
     * @return Whether the targetBuffer field is set.
     */
    boolean hasTargetBuffer();
    /**
     * <pre>
     * The index of the logging buffer where TracePacket(s) will be stored.
     * This field doesn't make a major difference for the Producer(s). The final
     * logging buffers, in fact, are completely owned by the Service. We just ask
     * the Producer to copy this number into the chunk headers it emits, so that
     * the Service can quickly identify the buffer where to move the chunks into
     * without expensive lookups on its fastpath.
     * </pre>
     *
     * <code>optional uint32 target_buffer = 2;</code>
     * @return The targetBuffer.
     */
    int getTargetBuffer();

    /**
     * <pre>
     * Set by the service to indicate the duration of the trace.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint32 trace_duration_ms = 3;</code>
     * @return Whether the traceDurationMs field is set.
     */
    boolean hasTraceDurationMs();
    /**
     * <pre>
     * Set by the service to indicate the duration of the trace.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint32 trace_duration_ms = 3;</code>
     * @return The traceDurationMs.
     */
    int getTraceDurationMs();

    /**
     * <pre>
     * If true, |trace_duration_ms| should count also time in suspend. This
     * is propagated from TraceConfig.prefer_suspend_clock_for_duration.
     * </pre>
     *
     * <code>optional bool prefer_suspend_clock_for_duration = 122;</code>
     * @return Whether the preferSuspendClockForDuration field is set.
     */
    boolean hasPreferSuspendClockForDuration();
    /**
     * <pre>
     * If true, |trace_duration_ms| should count also time in suspend. This
     * is propagated from TraceConfig.prefer_suspend_clock_for_duration.
     * </pre>
     *
     * <code>optional bool prefer_suspend_clock_for_duration = 122;</code>
     * @return The preferSuspendClockForDuration.
     */
    boolean getPreferSuspendClockForDuration();

    /**
     * <pre>
     * Set by the service to indicate how long it waits after StopDataSource.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint32 stop_timeout_ms = 7;</code>
     * @return Whether the stopTimeoutMs field is set.
     */
    boolean hasStopTimeoutMs();
    /**
     * <pre>
     * Set by the service to indicate how long it waits after StopDataSource.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint32 stop_timeout_ms = 7;</code>
     * @return The stopTimeoutMs.
     */
    int getStopTimeoutMs();

    /**
     * <pre>
     * Set by the service to indicate whether this tracing session has extra
     * guardrails.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional bool enable_extra_guardrails = 6;</code>
     * @return Whether the enableExtraGuardrails field is set.
     */
    boolean hasEnableExtraGuardrails();
    /**
     * <pre>
     * Set by the service to indicate whether this tracing session has extra
     * guardrails.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional bool enable_extra_guardrails = 6;</code>
     * @return The enableExtraGuardrails.
     */
    boolean getEnableExtraGuardrails();

    /**
     * <pre>
     * Set by the service to indicate which user initiated this trace.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional .perfetto.protos.DataSourceConfig.SessionInitiator session_initiator = 8;</code>
     * @return Whether the sessionInitiator field is set.
     */
    boolean hasSessionInitiator();
    /**
     * <pre>
     * Set by the service to indicate which user initiated this trace.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional .perfetto.protos.DataSourceConfig.SessionInitiator session_initiator = 8;</code>
     * @return The sessionInitiator.
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator getSessionInitiator();

    /**
     * <pre>
     * Set by the service to indicate which tracing session the data source
     * belongs to. The intended use case for this is checking if two data sources,
     * one of which produces metadata for the other one, belong to the same trace
     * session and hence should be linked together.
     * This field was introduced in Aug 2018 after Android P.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint64 tracing_session_id = 4;</code>
     * @return Whether the tracingSessionId field is set.
     */
    boolean hasTracingSessionId();
    /**
     * <pre>
     * Set by the service to indicate which tracing session the data source
     * belongs to. The intended use case for this is checking if two data sources,
     * one of which produces metadata for the other one, belong to the same trace
     * session and hence should be linked together.
     * This field was introduced in Aug 2018 after Android P.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint64 tracing_session_id = 4;</code>
     * @return The tracingSessionId.
     */
    long getTracingSessionId();

    /**
     * <pre>
     * Data source name: gpu.counters
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
     * @return Whether the gpuCounterConfig field is set.
     */
    boolean hasGpuCounterConfig();
    /**
     * <pre>
     * Data source name: gpu.counters
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
     * @return The gpuCounterConfig.
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig getGpuCounterConfig();
    /**
     * <pre>
     * Data source name: gpu.counters
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfigOrBuilder getGpuCounterConfigOrBuilder();

    /**
     * <pre>
     * Data source name: vulkan.memory_tracker
     * </pre>
     *
     * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
     * @return Whether the vulkanMemoryConfig field is set.
     */
    boolean hasVulkanMemoryConfig();
    /**
     * <pre>
     * Data source name: vulkan.memory_tracker
     * </pre>
     *
     * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
     * @return The vulkanMemoryConfig.
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig getVulkanMemoryConfig();
    /**
     * <pre>
     * Data source name: vulkan.memory_tracker
     * </pre>
     *
     * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfigOrBuilder getVulkanMemoryConfigOrBuilder();

    /**
     * <pre>
     * Data source name: track_event
     * </pre>
     *
     * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
     * @return Whether the trackEventConfig field is set.
     */
    boolean hasTrackEventConfig();
    /**
     * <pre>
     * Data source name: track_event
     * </pre>
     *
     * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
     * @return The trackEventConfig.
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig getTrackEventConfig();
    /**
     * <pre>
     * Data source name: track_event
     * </pre>
     *
     * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfigOrBuilder getTrackEventConfigOrBuilder();

    /**
     * <pre>
     * If an interceptor is specified here, packets for this data source will be
     * rerouted to the interceptor instead of the main trace buffer. This can be
     * used, for example, to write trace data into ETW or for logging trace points
     * to the console.
     *
     * Note that interceptors are only supported by data sources registered
     * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
     * traced_probes) may not support interception.
     * </pre>
     *
     * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
     * @return Whether the interceptorConfig field is set.
     */
    boolean hasInterceptorConfig();
    /**
     * <pre>
     * If an interceptor is specified here, packets for this data source will be
     * rerouted to the interceptor instead of the main trace buffer. This can be
     * used, for example, to write trace data into ETW or for logging trace points
     * to the console.
     *
     * Note that interceptors are only supported by data sources registered
     * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
     * traced_probes) may not support interception.
     * </pre>
     *
     * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
     * @return The interceptorConfig.
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig getInterceptorConfig();
    /**
     * <pre>
     * If an interceptor is specified here, packets for this data source will be
     * rerouted to the interceptor instead of the main trace buffer. This can be
     * used, for example, to write trace data into ETW or for logging trace points
     * to the console.
     *
     * Note that interceptors are only supported by data sources registered
     * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
     * traced_probes) may not support interception.
     * </pre>
     *
     * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfigOrBuilder getInterceptorConfigOrBuilder();

    /**
     * <pre>
     * Data source name: gpu.renderstages
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
     * @return Whether the gpuRenderstagesConfig field is set.
     */
    boolean hasGpuRenderstagesConfig();
    /**
     * <pre>
     * Data source name: gpu.renderstages
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
     * @return The gpuRenderstagesConfig.
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig getGpuRenderstagesConfig();
    /**
     * <pre>
     * Data source name: gpu.renderstages
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfigOrBuilder getGpuRenderstagesConfigOrBuilder();

    /**
     * <pre>
     * This is a fallback mechanism to send a free-form text config to the
     * producer. In theory this should never be needed. All the code that
     * is part of the platform (i.e. traced service) is supposed to *not* truncate
     * the trace config proto and propagate unknown fields. However, if anything
     * in the pipeline (client or backend) ends up breaking this forward compat
     * plan, this field will become the escape hatch to allow future data sources
     * to get some meaningful configuration.
     * </pre>
     *
     * <code>optional string legacy_config = 1000;</code>
     * @return Whether the legacyConfig field is set.
     */
    boolean hasLegacyConfig();
    /**
     * <pre>
     * This is a fallback mechanism to send a free-form text config to the
     * producer. In theory this should never be needed. All the code that
     * is part of the platform (i.e. traced service) is supposed to *not* truncate
     * the trace config proto and propagate unknown fields. However, if anything
     * in the pipeline (client or backend) ends up breaking this forward compat
     * plan, this field will become the escape hatch to allow future data sources
     * to get some meaningful configuration.
     * </pre>
     *
     * <code>optional string legacy_config = 1000;</code>
     * @return The legacyConfig.
     */
    java.lang.String getLegacyConfig();
    /**
     * <pre>
     * This is a fallback mechanism to send a free-form text config to the
     * producer. In theory this should never be needed. All the code that
     * is part of the platform (i.e. traced service) is supposed to *not* truncate
     * the trace config proto and propagate unknown fields. However, if anything
     * in the pipeline (client or backend) ends up breaking this forward compat
     * plan, this field will become the escape hatch to allow future data sources
     * to get some meaningful configuration.
     * </pre>
     *
     * <code>optional string legacy_config = 1000;</code>
     * @return The bytes for legacyConfig.
     */
    com.google.protobuf.ByteString
        getLegacyConfigBytes();

    /**
     * <pre>
     * This field is only used for testing.
     * </pre>
     *
     * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
     * @return Whether the forTesting field is set.
     */
    boolean hasForTesting();
    /**
     * <pre>
     * This field is only used for testing.
     * </pre>
     *
     * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
     * @return The forTesting.
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig getForTesting();
    /**
     * <pre>
     * This field is only used for testing.
     * </pre>
     *
     * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
     */
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfigOrBuilder getForTestingOrBuilder();
  }
  /**
   * <pre>
   * The configuration that is passed to each data source when starting tracing.
   * Next id: 134
   * </pre>
   *
   * Protobuf type {@code perfetto.protos.DataSourceConfig}
   */
  public static final class DataSourceConfig extends
      com.google.protobuf.GeneratedMessage implements
      // @@protoc_insertion_point(message_implements:perfetto.protos.DataSourceConfig)
      DataSourceConfigOrBuilder {
  private static final long serialVersionUID = 0L;
    static {
      com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
        com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
        /* major= */ 4,
        /* minor= */ 29,
        /* patch= */ 3,
        /* suffix= */ "",
        DataSourceConfig.class.getName());
    }
    // Use DataSourceConfig.newBuilder() to construct.
    private DataSourceConfig(com.google.protobuf.GeneratedMessage.Builder<?> builder) {
      super(builder);
    }
    private DataSourceConfig() {
      name_ = "";
      sessionInitiator_ = 0;
      legacyConfig_ = "";
    }

    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.internal_static_perfetto_protos_DataSourceConfig_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.internal_static_perfetto_protos_DataSourceConfig_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.class, org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.Builder.class);
    }

    /**
     * Protobuf enum {@code perfetto.protos.DataSourceConfig.SessionInitiator}
     */
    public enum SessionInitiator
        implements com.google.protobuf.ProtocolMessageEnum {
      /**
       * <code>SESSION_INITIATOR_UNSPECIFIED = 0;</code>
       */
      SESSION_INITIATOR_UNSPECIFIED(0),
      /**
       * <pre>
       * This trace was initiated from a trusted system app has DUMP and
       * USAGE_STATS permission. This system app is expected to not expose the
       * trace to the user of the device.
       * This is determined by checking the UID initiating the trace.
       * </pre>
       *
       * <code>SESSION_INITIATOR_TRUSTED_SYSTEM = 1;</code>
       */
      SESSION_INITIATOR_TRUSTED_SYSTEM(1),
      ;

      static {
        com.google.protobuf.RuntimeVersion.validateProtobufGencodeVersion(
          com.google.protobuf.RuntimeVersion.RuntimeDomain.PUBLIC,
          /* major= */ 4,
          /* minor= */ 29,
          /* patch= */ 3,
          /* suffix= */ "",
          SessionInitiator.class.getName());
      }
      /**
       * <code>SESSION_INITIATOR_UNSPECIFIED = 0;</code>
       */
      public static final int SESSION_INITIATOR_UNSPECIFIED_VALUE = 0;
      /**
       * <pre>
       * This trace was initiated from a trusted system app has DUMP and
       * USAGE_STATS permission. This system app is expected to not expose the
       * trace to the user of the device.
       * This is determined by checking the UID initiating the trace.
       * </pre>
       *
       * <code>SESSION_INITIATOR_TRUSTED_SYSTEM = 1;</code>
       */
      public static final int SESSION_INITIATOR_TRUSTED_SYSTEM_VALUE = 1;


      public final int getNumber() {
        return value;
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       * @deprecated Use {@link #forNumber(int)} instead.
       */
      @java.lang.Deprecated
      public static SessionInitiator valueOf(int value) {
        return forNumber(value);
      }

      /**
       * @param value The numeric wire value of the corresponding enum entry.
       * @return The enum associated with the given numeric wire value.
       */
      public static SessionInitiator forNumber(int value) {
        switch (value) {
          case 0: return SESSION_INITIATOR_UNSPECIFIED;
          case 1: return SESSION_INITIATOR_TRUSTED_SYSTEM;
          default: return null;
        }
      }

      public static com.google.protobuf.Internal.EnumLiteMap<SessionInitiator>
          internalGetValueMap() {
        return internalValueMap;
      }
      private static final com.google.protobuf.Internal.EnumLiteMap<
          SessionInitiator> internalValueMap =
            new com.google.protobuf.Internal.EnumLiteMap<SessionInitiator>() {
              public SessionInitiator findValueByNumber(int number) {
                return SessionInitiator.forNumber(number);
              }
            };

      public final com.google.protobuf.Descriptors.EnumValueDescriptor
          getValueDescriptor() {
        return getDescriptor().getValues().get(ordinal());
      }
      public final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptorForType() {
        return getDescriptor();
      }
      public static final com.google.protobuf.Descriptors.EnumDescriptor
          getDescriptor() {
        return org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.getDescriptor().getEnumTypes().get(0);
      }

      private static final SessionInitiator[] VALUES = values();

      public static SessionInitiator valueOf(
          com.google.protobuf.Descriptors.EnumValueDescriptor desc) {
        if (desc.getType() != getDescriptor()) {
          throw new java.lang.IllegalArgumentException(
            "EnumValueDescriptor is not for this type.");
        }
        return VALUES[desc.getIndex()];
      }

      private final int value;

      private SessionInitiator(int value) {
        this.value = value;
      }

      // @@protoc_insertion_point(enum_scope:perfetto.protos.DataSourceConfig.SessionInitiator)
    }

    private int bitField0_;
    public static final int NAME_FIELD_NUMBER = 1;
    @SuppressWarnings("serial")
    private volatile java.lang.Object name_ = "";
    /**
     * <pre>
     * Data source unique name, e.g., "linux.ftrace". This must match
     * the name passed by the data source when it registers (see
     * RegisterDataSource()).
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return Whether the name field is set.
     */
    @java.lang.Override
    public boolean hasName() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * Data source unique name, e.g., "linux.ftrace". This must match
     * the name passed by the data source when it registers (see
     * RegisterDataSource()).
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The name.
     */
    @java.lang.Override
    public java.lang.String getName() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          name_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * Data source unique name, e.g., "linux.ftrace". This must match
     * the name passed by the data source when it registers (see
     * RegisterDataSource()).
     * </pre>
     *
     * <code>optional string name = 1;</code>
     * @return The bytes for name.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getNameBytes() {
      java.lang.Object ref = name_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        name_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int TARGET_BUFFER_FIELD_NUMBER = 2;
    private int targetBuffer_ = 0;
    /**
     * <pre>
     * The index of the logging buffer where TracePacket(s) will be stored.
     * This field doesn't make a major difference for the Producer(s). The final
     * logging buffers, in fact, are completely owned by the Service. We just ask
     * the Producer to copy this number into the chunk headers it emits, so that
     * the Service can quickly identify the buffer where to move the chunks into
     * without expensive lookups on its fastpath.
     * </pre>
     *
     * <code>optional uint32 target_buffer = 2;</code>
     * @return Whether the targetBuffer field is set.
     */
    @java.lang.Override
    public boolean hasTargetBuffer() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * The index of the logging buffer where TracePacket(s) will be stored.
     * This field doesn't make a major difference for the Producer(s). The final
     * logging buffers, in fact, are completely owned by the Service. We just ask
     * the Producer to copy this number into the chunk headers it emits, so that
     * the Service can quickly identify the buffer where to move the chunks into
     * without expensive lookups on its fastpath.
     * </pre>
     *
     * <code>optional uint32 target_buffer = 2;</code>
     * @return The targetBuffer.
     */
    @java.lang.Override
    public int getTargetBuffer() {
      return targetBuffer_;
    }

    public static final int TRACE_DURATION_MS_FIELD_NUMBER = 3;
    private int traceDurationMs_ = 0;
    /**
     * <pre>
     * Set by the service to indicate the duration of the trace.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint32 trace_duration_ms = 3;</code>
     * @return Whether the traceDurationMs field is set.
     */
    @java.lang.Override
    public boolean hasTraceDurationMs() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Set by the service to indicate the duration of the trace.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint32 trace_duration_ms = 3;</code>
     * @return The traceDurationMs.
     */
    @java.lang.Override
    public int getTraceDurationMs() {
      return traceDurationMs_;
    }

    public static final int PREFER_SUSPEND_CLOCK_FOR_DURATION_FIELD_NUMBER = 122;
    private boolean preferSuspendClockForDuration_ = false;
    /**
     * <pre>
     * If true, |trace_duration_ms| should count also time in suspend. This
     * is propagated from TraceConfig.prefer_suspend_clock_for_duration.
     * </pre>
     *
     * <code>optional bool prefer_suspend_clock_for_duration = 122;</code>
     * @return Whether the preferSuspendClockForDuration field is set.
     */
    @java.lang.Override
    public boolean hasPreferSuspendClockForDuration() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * If true, |trace_duration_ms| should count also time in suspend. This
     * is propagated from TraceConfig.prefer_suspend_clock_for_duration.
     * </pre>
     *
     * <code>optional bool prefer_suspend_clock_for_duration = 122;</code>
     * @return The preferSuspendClockForDuration.
     */
    @java.lang.Override
    public boolean getPreferSuspendClockForDuration() {
      return preferSuspendClockForDuration_;
    }

    public static final int STOP_TIMEOUT_MS_FIELD_NUMBER = 7;
    private int stopTimeoutMs_ = 0;
    /**
     * <pre>
     * Set by the service to indicate how long it waits after StopDataSource.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint32 stop_timeout_ms = 7;</code>
     * @return Whether the stopTimeoutMs field is set.
     */
    @java.lang.Override
    public boolean hasStopTimeoutMs() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Set by the service to indicate how long it waits after StopDataSource.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint32 stop_timeout_ms = 7;</code>
     * @return The stopTimeoutMs.
     */
    @java.lang.Override
    public int getStopTimeoutMs() {
      return stopTimeoutMs_;
    }

    public static final int ENABLE_EXTRA_GUARDRAILS_FIELD_NUMBER = 6;
    private boolean enableExtraGuardrails_ = false;
    /**
     * <pre>
     * Set by the service to indicate whether this tracing session has extra
     * guardrails.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional bool enable_extra_guardrails = 6;</code>
     * @return Whether the enableExtraGuardrails field is set.
     */
    @java.lang.Override
    public boolean hasEnableExtraGuardrails() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * Set by the service to indicate whether this tracing session has extra
     * guardrails.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional bool enable_extra_guardrails = 6;</code>
     * @return The enableExtraGuardrails.
     */
    @java.lang.Override
    public boolean getEnableExtraGuardrails() {
      return enableExtraGuardrails_;
    }

    public static final int SESSION_INITIATOR_FIELD_NUMBER = 8;
    private int sessionInitiator_ = 0;
    /**
     * <pre>
     * Set by the service to indicate which user initiated this trace.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional .perfetto.protos.DataSourceConfig.SessionInitiator session_initiator = 8;</code>
     * @return Whether the sessionInitiator field is set.
     */
    @java.lang.Override public boolean hasSessionInitiator() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Set by the service to indicate which user initiated this trace.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional .perfetto.protos.DataSourceConfig.SessionInitiator session_initiator = 8;</code>
     * @return The sessionInitiator.
     */
    @java.lang.Override public org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator getSessionInitiator() {
      org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator result = org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator.forNumber(sessionInitiator_);
      return result == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator.SESSION_INITIATOR_UNSPECIFIED : result;
    }

    public static final int TRACING_SESSION_ID_FIELD_NUMBER = 4;
    private long tracingSessionId_ = 0L;
    /**
     * <pre>
     * Set by the service to indicate which tracing session the data source
     * belongs to. The intended use case for this is checking if two data sources,
     * one of which produces metadata for the other one, belong to the same trace
     * session and hence should be linked together.
     * This field was introduced in Aug 2018 after Android P.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint64 tracing_session_id = 4;</code>
     * @return Whether the tracingSessionId field is set.
     */
    @java.lang.Override
    public boolean hasTracingSessionId() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Set by the service to indicate which tracing session the data source
     * belongs to. The intended use case for this is checking if two data sources,
     * one of which produces metadata for the other one, belong to the same trace
     * session and hence should be linked together.
     * This field was introduced in Aug 2018 after Android P.
     * DO NOT SET in consumer as this will be overridden by the service.
     * </pre>
     *
     * <code>optional uint64 tracing_session_id = 4;</code>
     * @return The tracingSessionId.
     */
    @java.lang.Override
    public long getTracingSessionId() {
      return tracingSessionId_;
    }

    public static final int GPU_COUNTER_CONFIG_FIELD_NUMBER = 108;
    private org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig gpuCounterConfig_;
    /**
     * <pre>
     * Data source name: gpu.counters
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
     * @return Whether the gpuCounterConfig field is set.
     */
    @java.lang.Override
    public boolean hasGpuCounterConfig() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Data source name: gpu.counters
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
     * @return The gpuCounterConfig.
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig getGpuCounterConfig() {
      return gpuCounterConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig.getDefaultInstance() : gpuCounterConfig_;
    }
    /**
     * <pre>
     * Data source name: gpu.counters
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfigOrBuilder getGpuCounterConfigOrBuilder() {
      return gpuCounterConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig.getDefaultInstance() : gpuCounterConfig_;
    }

    public static final int VULKAN_MEMORY_CONFIG_FIELD_NUMBER = 112;
    private org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig vulkanMemoryConfig_;
    /**
     * <pre>
     * Data source name: vulkan.memory_tracker
     * </pre>
     *
     * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
     * @return Whether the vulkanMemoryConfig field is set.
     */
    @java.lang.Override
    public boolean hasVulkanMemoryConfig() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Data source name: vulkan.memory_tracker
     * </pre>
     *
     * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
     * @return The vulkanMemoryConfig.
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig getVulkanMemoryConfig() {
      return vulkanMemoryConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig.getDefaultInstance() : vulkanMemoryConfig_;
    }
    /**
     * <pre>
     * Data source name: vulkan.memory_tracker
     * </pre>
     *
     * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfigOrBuilder getVulkanMemoryConfigOrBuilder() {
      return vulkanMemoryConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig.getDefaultInstance() : vulkanMemoryConfig_;
    }

    public static final int TRACK_EVENT_CONFIG_FIELD_NUMBER = 113;
    private org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig trackEventConfig_;
    /**
     * <pre>
     * Data source name: track_event
     * </pre>
     *
     * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
     * @return Whether the trackEventConfig field is set.
     */
    @java.lang.Override
    public boolean hasTrackEventConfig() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Data source name: track_event
     * </pre>
     *
     * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
     * @return The trackEventConfig.
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig getTrackEventConfig() {
      return trackEventConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig.getDefaultInstance() : trackEventConfig_;
    }
    /**
     * <pre>
     * Data source name: track_event
     * </pre>
     *
     * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfigOrBuilder getTrackEventConfigOrBuilder() {
      return trackEventConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig.getDefaultInstance() : trackEventConfig_;
    }

    public static final int INTERCEPTOR_CONFIG_FIELD_NUMBER = 115;
    private org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig interceptorConfig_;
    /**
     * <pre>
     * If an interceptor is specified here, packets for this data source will be
     * rerouted to the interceptor instead of the main trace buffer. This can be
     * used, for example, to write trace data into ETW or for logging trace points
     * to the console.
     *
     * Note that interceptors are only supported by data sources registered
     * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
     * traced_probes) may not support interception.
     * </pre>
     *
     * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
     * @return Whether the interceptorConfig field is set.
     */
    @java.lang.Override
    public boolean hasInterceptorConfig() {
      return ((bitField0_ & 0x00000800) != 0);
    }
    /**
     * <pre>
     * If an interceptor is specified here, packets for this data source will be
     * rerouted to the interceptor instead of the main trace buffer. This can be
     * used, for example, to write trace data into ETW or for logging trace points
     * to the console.
     *
     * Note that interceptors are only supported by data sources registered
     * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
     * traced_probes) may not support interception.
     * </pre>
     *
     * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
     * @return The interceptorConfig.
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig getInterceptorConfig() {
      return interceptorConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig.getDefaultInstance() : interceptorConfig_;
    }
    /**
     * <pre>
     * If an interceptor is specified here, packets for this data source will be
     * rerouted to the interceptor instead of the main trace buffer. This can be
     * used, for example, to write trace data into ETW or for logging trace points
     * to the console.
     *
     * Note that interceptors are only supported by data sources registered
     * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
     * traced_probes) may not support interception.
     * </pre>
     *
     * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfigOrBuilder getInterceptorConfigOrBuilder() {
      return interceptorConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig.getDefaultInstance() : interceptorConfig_;
    }

    public static final int GPU_RENDERSTAGES_CONFIG_FIELD_NUMBER = 133;
    private org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig gpuRenderstagesConfig_;
    /**
     * <pre>
     * Data source name: gpu.renderstages
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
     * @return Whether the gpuRenderstagesConfig field is set.
     */
    @java.lang.Override
    public boolean hasGpuRenderstagesConfig() {
      return ((bitField0_ & 0x00001000) != 0);
    }
    /**
     * <pre>
     * Data source name: gpu.renderstages
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
     * @return The gpuRenderstagesConfig.
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig getGpuRenderstagesConfig() {
      return gpuRenderstagesConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig.getDefaultInstance() : gpuRenderstagesConfig_;
    }
    /**
     * <pre>
     * Data source name: gpu.renderstages
     * </pre>
     *
     * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfigOrBuilder getGpuRenderstagesConfigOrBuilder() {
      return gpuRenderstagesConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig.getDefaultInstance() : gpuRenderstagesConfig_;
    }

    public static final int LEGACY_CONFIG_FIELD_NUMBER = 1000;
    @SuppressWarnings("serial")
    private volatile java.lang.Object legacyConfig_ = "";
    /**
     * <pre>
     * This is a fallback mechanism to send a free-form text config to the
     * producer. In theory this should never be needed. All the code that
     * is part of the platform (i.e. traced service) is supposed to *not* truncate
     * the trace config proto and propagate unknown fields. However, if anything
     * in the pipeline (client or backend) ends up breaking this forward compat
     * plan, this field will become the escape hatch to allow future data sources
     * to get some meaningful configuration.
     * </pre>
     *
     * <code>optional string legacy_config = 1000;</code>
     * @return Whether the legacyConfig field is set.
     */
    @java.lang.Override
    public boolean hasLegacyConfig() {
      return ((bitField0_ & 0x00002000) != 0);
    }
    /**
     * <pre>
     * This is a fallback mechanism to send a free-form text config to the
     * producer. In theory this should never be needed. All the code that
     * is part of the platform (i.e. traced service) is supposed to *not* truncate
     * the trace config proto and propagate unknown fields. However, if anything
     * in the pipeline (client or backend) ends up breaking this forward compat
     * plan, this field will become the escape hatch to allow future data sources
     * to get some meaningful configuration.
     * </pre>
     *
     * <code>optional string legacy_config = 1000;</code>
     * @return The legacyConfig.
     */
    @java.lang.Override
    public java.lang.String getLegacyConfig() {
      java.lang.Object ref = legacyConfig_;
      if (ref instanceof java.lang.String) {
        return (java.lang.String) ref;
      } else {
        com.google.protobuf.ByteString bs =
            (com.google.protobuf.ByteString) ref;
        java.lang.String s = bs.toStringUtf8();
        if (bs.isValidUtf8()) {
          legacyConfig_ = s;
        }
        return s;
      }
    }
    /**
     * <pre>
     * This is a fallback mechanism to send a free-form text config to the
     * producer. In theory this should never be needed. All the code that
     * is part of the platform (i.e. traced service) is supposed to *not* truncate
     * the trace config proto and propagate unknown fields. However, if anything
     * in the pipeline (client or backend) ends up breaking this forward compat
     * plan, this field will become the escape hatch to allow future data sources
     * to get some meaningful configuration.
     * </pre>
     *
     * <code>optional string legacy_config = 1000;</code>
     * @return The bytes for legacyConfig.
     */
    @java.lang.Override
    public com.google.protobuf.ByteString
        getLegacyConfigBytes() {
      java.lang.Object ref = legacyConfig_;
      if (ref instanceof java.lang.String) {
        com.google.protobuf.ByteString b =
            com.google.protobuf.ByteString.copyFromUtf8(
                (java.lang.String) ref);
        legacyConfig_ = b;
        return b;
      } else {
        return (com.google.protobuf.ByteString) ref;
      }
    }

    public static final int FOR_TESTING_FIELD_NUMBER = 1001;
    private org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig forTesting_;
    /**
     * <pre>
     * This field is only used for testing.
     * </pre>
     *
     * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
     * @return Whether the forTesting field is set.
     */
    @java.lang.Override
    public boolean hasForTesting() {
      return ((bitField0_ & 0x00004000) != 0);
    }
    /**
     * <pre>
     * This field is only used for testing.
     * </pre>
     *
     * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
     * @return The forTesting.
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig getForTesting() {
      return forTesting_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig.getDefaultInstance() : forTesting_;
    }
    /**
     * <pre>
     * This field is only used for testing.
     * </pre>
     *
     * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
     */
    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfigOrBuilder getForTestingOrBuilder() {
      return forTesting_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig.getDefaultInstance() : forTesting_;
    }

    private byte memoizedIsInitialized = -1;
    @java.lang.Override
    public final boolean isInitialized() {
      byte isInitialized = memoizedIsInitialized;
      if (isInitialized == 1) return true;
      if (isInitialized == 0) return false;

      memoizedIsInitialized = 1;
      return true;
    }

    @java.lang.Override
    public void writeTo(com.google.protobuf.CodedOutputStream output)
                        throws java.io.IOException {
      if (((bitField0_ & 0x00000001) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        output.writeUInt32(2, targetBuffer_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        output.writeUInt32(3, traceDurationMs_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        output.writeUInt64(4, tracingSessionId_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        output.writeBool(6, enableExtraGuardrails_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        output.writeUInt32(7, stopTimeoutMs_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        output.writeEnum(8, sessionInitiator_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        output.writeMessage(108, getGpuCounterConfig());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        output.writeMessage(112, getVulkanMemoryConfig());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        output.writeMessage(113, getTrackEventConfig());
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        output.writeMessage(115, getInterceptorConfig());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        output.writeBool(122, preferSuspendClockForDuration_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        output.writeMessage(133, getGpuRenderstagesConfig());
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        com.google.protobuf.GeneratedMessage.writeString(output, 1000, legacyConfig_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        output.writeMessage(1001, getForTesting());
      }
      getUnknownFields().writeTo(output);
    }

    @java.lang.Override
    public int getSerializedSize() {
      int size = memoizedSize;
      if (size != -1) return size;

      size = 0;
      if (((bitField0_ & 0x00000001) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1, name_);
      }
      if (((bitField0_ & 0x00000002) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(2, targetBuffer_);
      }
      if (((bitField0_ & 0x00000004) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(3, traceDurationMs_);
      }
      if (((bitField0_ & 0x00000080) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt64Size(4, tracingSessionId_);
      }
      if (((bitField0_ & 0x00000020) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(6, enableExtraGuardrails_);
      }
      if (((bitField0_ & 0x00000010) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeUInt32Size(7, stopTimeoutMs_);
      }
      if (((bitField0_ & 0x00000040) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeEnumSize(8, sessionInitiator_);
      }
      if (((bitField0_ & 0x00000100) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(108, getGpuCounterConfig());
      }
      if (((bitField0_ & 0x00000200) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(112, getVulkanMemoryConfig());
      }
      if (((bitField0_ & 0x00000400) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(113, getTrackEventConfig());
      }
      if (((bitField0_ & 0x00000800) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(115, getInterceptorConfig());
      }
      if (((bitField0_ & 0x00000008) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeBoolSize(122, preferSuspendClockForDuration_);
      }
      if (((bitField0_ & 0x00001000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(133, getGpuRenderstagesConfig());
      }
      if (((bitField0_ & 0x00002000) != 0)) {
        size += com.google.protobuf.GeneratedMessage.computeStringSize(1000, legacyConfig_);
      }
      if (((bitField0_ & 0x00004000) != 0)) {
        size += com.google.protobuf.CodedOutputStream
          .computeMessageSize(1001, getForTesting());
      }
      size += getUnknownFields().getSerializedSize();
      memoizedSize = size;
      return size;
    }

    @java.lang.Override
    public boolean equals(final java.lang.Object obj) {
      if (obj == this) {
       return true;
      }
      if (!(obj instanceof org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig)) {
        return super.equals(obj);
      }
      org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig other = (org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig) obj;

      if (hasName() != other.hasName()) return false;
      if (hasName()) {
        if (!getName()
            .equals(other.getName())) return false;
      }
      if (hasTargetBuffer() != other.hasTargetBuffer()) return false;
      if (hasTargetBuffer()) {
        if (getTargetBuffer()
            != other.getTargetBuffer()) return false;
      }
      if (hasTraceDurationMs() != other.hasTraceDurationMs()) return false;
      if (hasTraceDurationMs()) {
        if (getTraceDurationMs()
            != other.getTraceDurationMs()) return false;
      }
      if (hasPreferSuspendClockForDuration() != other.hasPreferSuspendClockForDuration()) return false;
      if (hasPreferSuspendClockForDuration()) {
        if (getPreferSuspendClockForDuration()
            != other.getPreferSuspendClockForDuration()) return false;
      }
      if (hasStopTimeoutMs() != other.hasStopTimeoutMs()) return false;
      if (hasStopTimeoutMs()) {
        if (getStopTimeoutMs()
            != other.getStopTimeoutMs()) return false;
      }
      if (hasEnableExtraGuardrails() != other.hasEnableExtraGuardrails()) return false;
      if (hasEnableExtraGuardrails()) {
        if (getEnableExtraGuardrails()
            != other.getEnableExtraGuardrails()) return false;
      }
      if (hasSessionInitiator() != other.hasSessionInitiator()) return false;
      if (hasSessionInitiator()) {
        if (sessionInitiator_ != other.sessionInitiator_) return false;
      }
      if (hasTracingSessionId() != other.hasTracingSessionId()) return false;
      if (hasTracingSessionId()) {
        if (getTracingSessionId()
            != other.getTracingSessionId()) return false;
      }
      if (hasGpuCounterConfig() != other.hasGpuCounterConfig()) return false;
      if (hasGpuCounterConfig()) {
        if (!getGpuCounterConfig()
            .equals(other.getGpuCounterConfig())) return false;
      }
      if (hasVulkanMemoryConfig() != other.hasVulkanMemoryConfig()) return false;
      if (hasVulkanMemoryConfig()) {
        if (!getVulkanMemoryConfig()
            .equals(other.getVulkanMemoryConfig())) return false;
      }
      if (hasTrackEventConfig() != other.hasTrackEventConfig()) return false;
      if (hasTrackEventConfig()) {
        if (!getTrackEventConfig()
            .equals(other.getTrackEventConfig())) return false;
      }
      if (hasInterceptorConfig() != other.hasInterceptorConfig()) return false;
      if (hasInterceptorConfig()) {
        if (!getInterceptorConfig()
            .equals(other.getInterceptorConfig())) return false;
      }
      if (hasGpuRenderstagesConfig() != other.hasGpuRenderstagesConfig()) return false;
      if (hasGpuRenderstagesConfig()) {
        if (!getGpuRenderstagesConfig()
            .equals(other.getGpuRenderstagesConfig())) return false;
      }
      if (hasLegacyConfig() != other.hasLegacyConfig()) return false;
      if (hasLegacyConfig()) {
        if (!getLegacyConfig()
            .equals(other.getLegacyConfig())) return false;
      }
      if (hasForTesting() != other.hasForTesting()) return false;
      if (hasForTesting()) {
        if (!getForTesting()
            .equals(other.getForTesting())) return false;
      }
      if (!getUnknownFields().equals(other.getUnknownFields())) return false;
      return true;
    }

    @java.lang.Override
    public int hashCode() {
      if (memoizedHashCode != 0) {
        return memoizedHashCode;
      }
      int hash = 41;
      hash = (19 * hash) + getDescriptor().hashCode();
      if (hasName()) {
        hash = (37 * hash) + NAME_FIELD_NUMBER;
        hash = (53 * hash) + getName().hashCode();
      }
      if (hasTargetBuffer()) {
        hash = (37 * hash) + TARGET_BUFFER_FIELD_NUMBER;
        hash = (53 * hash) + getTargetBuffer();
      }
      if (hasTraceDurationMs()) {
        hash = (37 * hash) + TRACE_DURATION_MS_FIELD_NUMBER;
        hash = (53 * hash) + getTraceDurationMs();
      }
      if (hasPreferSuspendClockForDuration()) {
        hash = (37 * hash) + PREFER_SUSPEND_CLOCK_FOR_DURATION_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getPreferSuspendClockForDuration());
      }
      if (hasStopTimeoutMs()) {
        hash = (37 * hash) + STOP_TIMEOUT_MS_FIELD_NUMBER;
        hash = (53 * hash) + getStopTimeoutMs();
      }
      if (hasEnableExtraGuardrails()) {
        hash = (37 * hash) + ENABLE_EXTRA_GUARDRAILS_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
            getEnableExtraGuardrails());
      }
      if (hasSessionInitiator()) {
        hash = (37 * hash) + SESSION_INITIATOR_FIELD_NUMBER;
        hash = (53 * hash) + sessionInitiator_;
      }
      if (hasTracingSessionId()) {
        hash = (37 * hash) + TRACING_SESSION_ID_FIELD_NUMBER;
        hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
            getTracingSessionId());
      }
      if (hasGpuCounterConfig()) {
        hash = (37 * hash) + GPU_COUNTER_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getGpuCounterConfig().hashCode();
      }
      if (hasVulkanMemoryConfig()) {
        hash = (37 * hash) + VULKAN_MEMORY_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getVulkanMemoryConfig().hashCode();
      }
      if (hasTrackEventConfig()) {
        hash = (37 * hash) + TRACK_EVENT_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getTrackEventConfig().hashCode();
      }
      if (hasInterceptorConfig()) {
        hash = (37 * hash) + INTERCEPTOR_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getInterceptorConfig().hashCode();
      }
      if (hasGpuRenderstagesConfig()) {
        hash = (37 * hash) + GPU_RENDERSTAGES_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getGpuRenderstagesConfig().hashCode();
      }
      if (hasLegacyConfig()) {
        hash = (37 * hash) + LEGACY_CONFIG_FIELD_NUMBER;
        hash = (53 * hash) + getLegacyConfig().hashCode();
      }
      if (hasForTesting()) {
        hash = (37 * hash) + FOR_TESTING_FIELD_NUMBER;
        hash = (53 * hash) + getForTesting().hashCode();
      }
      hash = (29 * hash) + getUnknownFields().hashCode();
      memoizedHashCode = hash;
      return hash;
    }

    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseFrom(
        java.nio.ByteBuffer data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseFrom(
        java.nio.ByteBuffer data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseFrom(
        com.google.protobuf.ByteString data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseFrom(
        com.google.protobuf.ByteString data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseFrom(byte[] data)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data);
    }
    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseFrom(
        byte[] data,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return PARSER.parseFrom(data, extensionRegistry);
    }
    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseDelimitedFrom(java.io.InputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input);
    }

    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseDelimitedFrom(
        java.io.InputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
    }
    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseFrom(
        com.google.protobuf.CodedInputStream input)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input);
    }
    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig parseFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      return com.google.protobuf.GeneratedMessage
          .parseWithIOException(PARSER, input, extensionRegistry);
    }

    @java.lang.Override
    public Builder newBuilderForType() { return newBuilder(); }
    public static Builder newBuilder() {
      return DEFAULT_INSTANCE.toBuilder();
    }
    public static Builder newBuilder(org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig prototype) {
      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
    }
    @java.lang.Override
    public Builder toBuilder() {
      return this == DEFAULT_INSTANCE
          ? new Builder() : new Builder().mergeFrom(this);
    }

    @java.lang.Override
    protected Builder newBuilderForType(
        com.google.protobuf.GeneratedMessage.BuilderParent parent) {
      Builder builder = new Builder(parent);
      return builder;
    }
    /**
     * <pre>
     * The configuration that is passed to each data source when starting tracing.
     * Next id: 134
     * </pre>
     *
     * Protobuf type {@code perfetto.protos.DataSourceConfig}
     */
    public static final class Builder extends
        com.google.protobuf.GeneratedMessage.Builder<Builder> implements
        // @@protoc_insertion_point(builder_implements:perfetto.protos.DataSourceConfig)
        org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfigOrBuilder {
      public static final com.google.protobuf.Descriptors.Descriptor
          getDescriptor() {
        return org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.internal_static_perfetto_protos_DataSourceConfig_descriptor;
      }

      @java.lang.Override
      protected com.google.protobuf.GeneratedMessage.FieldAccessorTable
          internalGetFieldAccessorTable() {
        return org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.internal_static_perfetto_protos_DataSourceConfig_fieldAccessorTable
            .ensureFieldAccessorsInitialized(
                org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.class, org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.Builder.class);
      }

      // Construct using perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.newBuilder()
      private Builder() {
        maybeForceBuilderInitialization();
      }

      private Builder(
          com.google.protobuf.GeneratedMessage.BuilderParent parent) {
        super(parent);
        maybeForceBuilderInitialization();
      }
      private void maybeForceBuilderInitialization() {
        if (com.google.protobuf.GeneratedMessage
                .alwaysUseFieldBuilders) {
          getGpuCounterConfigFieldBuilder();
          getVulkanMemoryConfigFieldBuilder();
          getTrackEventConfigFieldBuilder();
          getInterceptorConfigFieldBuilder();
          getGpuRenderstagesConfigFieldBuilder();
          getForTestingFieldBuilder();
        }
      }
      @java.lang.Override
      public Builder clear() {
        super.clear();
        bitField0_ = 0;
        name_ = "";
        targetBuffer_ = 0;
        traceDurationMs_ = 0;
        preferSuspendClockForDuration_ = false;
        stopTimeoutMs_ = 0;
        enableExtraGuardrails_ = false;
        sessionInitiator_ = 0;
        tracingSessionId_ = 0L;
        gpuCounterConfig_ = null;
        if (gpuCounterConfigBuilder_ != null) {
          gpuCounterConfigBuilder_.dispose();
          gpuCounterConfigBuilder_ = null;
        }
        vulkanMemoryConfig_ = null;
        if (vulkanMemoryConfigBuilder_ != null) {
          vulkanMemoryConfigBuilder_.dispose();
          vulkanMemoryConfigBuilder_ = null;
        }
        trackEventConfig_ = null;
        if (trackEventConfigBuilder_ != null) {
          trackEventConfigBuilder_.dispose();
          trackEventConfigBuilder_ = null;
        }
        interceptorConfig_ = null;
        if (interceptorConfigBuilder_ != null) {
          interceptorConfigBuilder_.dispose();
          interceptorConfigBuilder_ = null;
        }
        gpuRenderstagesConfig_ = null;
        if (gpuRenderstagesConfigBuilder_ != null) {
          gpuRenderstagesConfigBuilder_.dispose();
          gpuRenderstagesConfigBuilder_ = null;
        }
        legacyConfig_ = "";
        forTesting_ = null;
        if (forTestingBuilder_ != null) {
          forTestingBuilder_.dispose();
          forTestingBuilder_ = null;
        }
        return this;
      }

      @java.lang.Override
      public com.google.protobuf.Descriptors.Descriptor
          getDescriptorForType() {
        return org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.internal_static_perfetto_protos_DataSourceConfig_descriptor;
      }

      @java.lang.Override
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig getDefaultInstanceForType() {
        return org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.getDefaultInstance();
      }

      @java.lang.Override
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig build() {
        org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig result = buildPartial();
        if (!result.isInitialized()) {
          throw newUninitializedMessageException(result);
        }
        return result;
      }

      @java.lang.Override
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig buildPartial() {
        org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig result = new org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig(this);
        if (bitField0_ != 0) { buildPartial0(result); }
        onBuilt();
        return result;
      }

      private void buildPartial0(org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig result) {
        int from_bitField0_ = bitField0_;
        int to_bitField0_ = 0;
        if (((from_bitField0_ & 0x00000001) != 0)) {
          result.name_ = name_;
          to_bitField0_ |= 0x00000001;
        }
        if (((from_bitField0_ & 0x00000002) != 0)) {
          result.targetBuffer_ = targetBuffer_;
          to_bitField0_ |= 0x00000002;
        }
        if (((from_bitField0_ & 0x00000004) != 0)) {
          result.traceDurationMs_ = traceDurationMs_;
          to_bitField0_ |= 0x00000004;
        }
        if (((from_bitField0_ & 0x00000008) != 0)) {
          result.preferSuspendClockForDuration_ = preferSuspendClockForDuration_;
          to_bitField0_ |= 0x00000008;
        }
        if (((from_bitField0_ & 0x00000010) != 0)) {
          result.stopTimeoutMs_ = stopTimeoutMs_;
          to_bitField0_ |= 0x00000010;
        }
        if (((from_bitField0_ & 0x00000020) != 0)) {
          result.enableExtraGuardrails_ = enableExtraGuardrails_;
          to_bitField0_ |= 0x00000020;
        }
        if (((from_bitField0_ & 0x00000040) != 0)) {
          result.sessionInitiator_ = sessionInitiator_;
          to_bitField0_ |= 0x00000040;
        }
        if (((from_bitField0_ & 0x00000080) != 0)) {
          result.tracingSessionId_ = tracingSessionId_;
          to_bitField0_ |= 0x00000080;
        }
        if (((from_bitField0_ & 0x00000100) != 0)) {
          result.gpuCounterConfig_ = gpuCounterConfigBuilder_ == null
              ? gpuCounterConfig_
              : gpuCounterConfigBuilder_.build();
          to_bitField0_ |= 0x00000100;
        }
        if (((from_bitField0_ & 0x00000200) != 0)) {
          result.vulkanMemoryConfig_ = vulkanMemoryConfigBuilder_ == null
              ? vulkanMemoryConfig_
              : vulkanMemoryConfigBuilder_.build();
          to_bitField0_ |= 0x00000200;
        }
        if (((from_bitField0_ & 0x00000400) != 0)) {
          result.trackEventConfig_ = trackEventConfigBuilder_ == null
              ? trackEventConfig_
              : trackEventConfigBuilder_.build();
          to_bitField0_ |= 0x00000400;
        }
        if (((from_bitField0_ & 0x00000800) != 0)) {
          result.interceptorConfig_ = interceptorConfigBuilder_ == null
              ? interceptorConfig_
              : interceptorConfigBuilder_.build();
          to_bitField0_ |= 0x00000800;
        }
        if (((from_bitField0_ & 0x00001000) != 0)) {
          result.gpuRenderstagesConfig_ = gpuRenderstagesConfigBuilder_ == null
              ? gpuRenderstagesConfig_
              : gpuRenderstagesConfigBuilder_.build();
          to_bitField0_ |= 0x00001000;
        }
        if (((from_bitField0_ & 0x00002000) != 0)) {
          result.legacyConfig_ = legacyConfig_;
          to_bitField0_ |= 0x00002000;
        }
        if (((from_bitField0_ & 0x00004000) != 0)) {
          result.forTesting_ = forTestingBuilder_ == null
              ? forTesting_
              : forTestingBuilder_.build();
          to_bitField0_ |= 0x00004000;
        }
        result.bitField0_ |= to_bitField0_;
      }

      @java.lang.Override
      public Builder mergeFrom(com.google.protobuf.Message other) {
        if (other instanceof org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig) {
          return mergeFrom((org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig)other);
        } else {
          super.mergeFrom(other);
          return this;
        }
      }

      public Builder mergeFrom(org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig other) {
        if (other == org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.getDefaultInstance()) return this;
        if (other.hasName()) {
          name_ = other.name_;
          bitField0_ |= 0x00000001;
          onChanged();
        }
        if (other.hasTargetBuffer()) {
          setTargetBuffer(other.getTargetBuffer());
        }
        if (other.hasTraceDurationMs()) {
          setTraceDurationMs(other.getTraceDurationMs());
        }
        if (other.hasPreferSuspendClockForDuration()) {
          setPreferSuspendClockForDuration(other.getPreferSuspendClockForDuration());
        }
        if (other.hasStopTimeoutMs()) {
          setStopTimeoutMs(other.getStopTimeoutMs());
        }
        if (other.hasEnableExtraGuardrails()) {
          setEnableExtraGuardrails(other.getEnableExtraGuardrails());
        }
        if (other.hasSessionInitiator()) {
          setSessionInitiator(other.getSessionInitiator());
        }
        if (other.hasTracingSessionId()) {
          setTracingSessionId(other.getTracingSessionId());
        }
        if (other.hasGpuCounterConfig()) {
          mergeGpuCounterConfig(other.getGpuCounterConfig());
        }
        if (other.hasVulkanMemoryConfig()) {
          mergeVulkanMemoryConfig(other.getVulkanMemoryConfig());
        }
        if (other.hasTrackEventConfig()) {
          mergeTrackEventConfig(other.getTrackEventConfig());
        }
        if (other.hasInterceptorConfig()) {
          mergeInterceptorConfig(other.getInterceptorConfig());
        }
        if (other.hasGpuRenderstagesConfig()) {
          mergeGpuRenderstagesConfig(other.getGpuRenderstagesConfig());
        }
        if (other.hasLegacyConfig()) {
          legacyConfig_ = other.legacyConfig_;
          bitField0_ |= 0x00002000;
          onChanged();
        }
        if (other.hasForTesting()) {
          mergeForTesting(other.getForTesting());
        }
        this.mergeUnknownFields(other.getUnknownFields());
        onChanged();
        return this;
      }

      @java.lang.Override
      public final boolean isInitialized() {
        return true;
      }

      @java.lang.Override
      public Builder mergeFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws java.io.IOException {
        if (extensionRegistry == null) {
          throw new java.lang.NullPointerException();
        }
        try {
          boolean done = false;
          while (!done) {
            int tag = input.readTag();
            switch (tag) {
              case 0:
                done = true;
                break;
              case 10: {
                name_ = input.readBytes();
                bitField0_ |= 0x00000001;
                break;
              } // case 10
              case 16: {
                targetBuffer_ = input.readUInt32();
                bitField0_ |= 0x00000002;
                break;
              } // case 16
              case 24: {
                traceDurationMs_ = input.readUInt32();
                bitField0_ |= 0x00000004;
                break;
              } // case 24
              case 32: {
                tracingSessionId_ = input.readUInt64();
                bitField0_ |= 0x00000080;
                break;
              } // case 32
              case 48: {
                enableExtraGuardrails_ = input.readBool();
                bitField0_ |= 0x00000020;
                break;
              } // case 48
              case 56: {
                stopTimeoutMs_ = input.readUInt32();
                bitField0_ |= 0x00000010;
                break;
              } // case 56
              case 64: {
                int tmpRaw = input.readEnum();
                org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator tmpValue =
                    org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator.forNumber(tmpRaw);
                if (tmpValue == null) {
                  mergeUnknownVarintField(8, tmpRaw);
                } else {
                  sessionInitiator_ = tmpRaw;
                  bitField0_ |= 0x00000040;
                }
                break;
              } // case 64
              case 866: {
                input.readMessage(
                    getGpuCounterConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000100;
                break;
              } // case 866
              case 898: {
                input.readMessage(
                    getVulkanMemoryConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000200;
                break;
              } // case 898
              case 906: {
                input.readMessage(
                    getTrackEventConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000400;
                break;
              } // case 906
              case 922: {
                input.readMessage(
                    getInterceptorConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00000800;
                break;
              } // case 922
              case 976: {
                preferSuspendClockForDuration_ = input.readBool();
                bitField0_ |= 0x00000008;
                break;
              } // case 976
              case 1066: {
                input.readMessage(
                    getGpuRenderstagesConfigFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00001000;
                break;
              } // case 1066
              case 8002: {
                legacyConfig_ = input.readBytes();
                bitField0_ |= 0x00002000;
                break;
              } // case 8002
              case 8010: {
                input.readMessage(
                    getForTestingFieldBuilder().getBuilder(),
                    extensionRegistry);
                bitField0_ |= 0x00004000;
                break;
              } // case 8010
              default: {
                if (!super.parseUnknownField(input, extensionRegistry, tag)) {
                  done = true; // was an endgroup tag
                }
                break;
              } // default:
            } // switch (tag)
          } // while (!done)
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.unwrapIOException();
        } finally {
          onChanged();
        } // finally
        return this;
      }
      private int bitField0_;

      private java.lang.Object name_ = "";
      /**
       * <pre>
       * Data source unique name, e.g., "linux.ftrace". This must match
       * the name passed by the data source when it registers (see
       * RegisterDataSource()).
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return Whether the name field is set.
       */
      public boolean hasName() {
        return ((bitField0_ & 0x00000001) != 0);
      }
      /**
       * <pre>
       * Data source unique name, e.g., "linux.ftrace". This must match
       * the name passed by the data source when it registers (see
       * RegisterDataSource()).
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The name.
       */
      public java.lang.String getName() {
        java.lang.Object ref = name_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            name_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * Data source unique name, e.g., "linux.ftrace". This must match
       * the name passed by the data source when it registers (see
       * RegisterDataSource()).
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return The bytes for name.
       */
      public com.google.protobuf.ByteString
          getNameBytes() {
        java.lang.Object ref = name_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          name_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * Data source unique name, e.g., "linux.ftrace". This must match
       * the name passed by the data source when it registers (see
       * RegisterDataSource()).
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The name to set.
       * @return This builder for chaining.
       */
      public Builder setName(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source unique name, e.g., "linux.ftrace". This must match
       * the name passed by the data source when it registers (see
       * RegisterDataSource()).
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @return This builder for chaining.
       */
      public Builder clearName() {
        name_ = getDefaultInstance().getName();
        bitField0_ = (bitField0_ & ~0x00000001);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source unique name, e.g., "linux.ftrace". This must match
       * the name passed by the data source when it registers (see
       * RegisterDataSource()).
       * </pre>
       *
       * <code>optional string name = 1;</code>
       * @param value The bytes for name to set.
       * @return This builder for chaining.
       */
      public Builder setNameBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        name_ = value;
        bitField0_ |= 0x00000001;
        onChanged();
        return this;
      }

      private int targetBuffer_ ;
      /**
       * <pre>
       * The index of the logging buffer where TracePacket(s) will be stored.
       * This field doesn't make a major difference for the Producer(s). The final
       * logging buffers, in fact, are completely owned by the Service. We just ask
       * the Producer to copy this number into the chunk headers it emits, so that
       * the Service can quickly identify the buffer where to move the chunks into
       * without expensive lookups on its fastpath.
       * </pre>
       *
       * <code>optional uint32 target_buffer = 2;</code>
       * @return Whether the targetBuffer field is set.
       */
      @java.lang.Override
      public boolean hasTargetBuffer() {
        return ((bitField0_ & 0x00000002) != 0);
      }
      /**
       * <pre>
       * The index of the logging buffer where TracePacket(s) will be stored.
       * This field doesn't make a major difference for the Producer(s). The final
       * logging buffers, in fact, are completely owned by the Service. We just ask
       * the Producer to copy this number into the chunk headers it emits, so that
       * the Service can quickly identify the buffer where to move the chunks into
       * without expensive lookups on its fastpath.
       * </pre>
       *
       * <code>optional uint32 target_buffer = 2;</code>
       * @return The targetBuffer.
       */
      @java.lang.Override
      public int getTargetBuffer() {
        return targetBuffer_;
      }
      /**
       * <pre>
       * The index of the logging buffer where TracePacket(s) will be stored.
       * This field doesn't make a major difference for the Producer(s). The final
       * logging buffers, in fact, are completely owned by the Service. We just ask
       * the Producer to copy this number into the chunk headers it emits, so that
       * the Service can quickly identify the buffer where to move the chunks into
       * without expensive lookups on its fastpath.
       * </pre>
       *
       * <code>optional uint32 target_buffer = 2;</code>
       * @param value The targetBuffer to set.
       * @return This builder for chaining.
       */
      public Builder setTargetBuffer(int value) {

        targetBuffer_ = value;
        bitField0_ |= 0x00000002;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * The index of the logging buffer where TracePacket(s) will be stored.
       * This field doesn't make a major difference for the Producer(s). The final
       * logging buffers, in fact, are completely owned by the Service. We just ask
       * the Producer to copy this number into the chunk headers it emits, so that
       * the Service can quickly identify the buffer where to move the chunks into
       * without expensive lookups on its fastpath.
       * </pre>
       *
       * <code>optional uint32 target_buffer = 2;</code>
       * @return This builder for chaining.
       */
      public Builder clearTargetBuffer() {
        bitField0_ = (bitField0_ & ~0x00000002);
        targetBuffer_ = 0;
        onChanged();
        return this;
      }

      private int traceDurationMs_ ;
      /**
       * <pre>
       * Set by the service to indicate the duration of the trace.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint32 trace_duration_ms = 3;</code>
       * @return Whether the traceDurationMs field is set.
       */
      @java.lang.Override
      public boolean hasTraceDurationMs() {
        return ((bitField0_ & 0x00000004) != 0);
      }
      /**
       * <pre>
       * Set by the service to indicate the duration of the trace.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint32 trace_duration_ms = 3;</code>
       * @return The traceDurationMs.
       */
      @java.lang.Override
      public int getTraceDurationMs() {
        return traceDurationMs_;
      }
      /**
       * <pre>
       * Set by the service to indicate the duration of the trace.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint32 trace_duration_ms = 3;</code>
       * @param value The traceDurationMs to set.
       * @return This builder for chaining.
       */
      public Builder setTraceDurationMs(int value) {

        traceDurationMs_ = value;
        bitField0_ |= 0x00000004;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Set by the service to indicate the duration of the trace.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint32 trace_duration_ms = 3;</code>
       * @return This builder for chaining.
       */
      public Builder clearTraceDurationMs() {
        bitField0_ = (bitField0_ & ~0x00000004);
        traceDurationMs_ = 0;
        onChanged();
        return this;
      }

      private boolean preferSuspendClockForDuration_ ;
      /**
       * <pre>
       * If true, |trace_duration_ms| should count also time in suspend. This
       * is propagated from TraceConfig.prefer_suspend_clock_for_duration.
       * </pre>
       *
       * <code>optional bool prefer_suspend_clock_for_duration = 122;</code>
       * @return Whether the preferSuspendClockForDuration field is set.
       */
      @java.lang.Override
      public boolean hasPreferSuspendClockForDuration() {
        return ((bitField0_ & 0x00000008) != 0);
      }
      /**
       * <pre>
       * If true, |trace_duration_ms| should count also time in suspend. This
       * is propagated from TraceConfig.prefer_suspend_clock_for_duration.
       * </pre>
       *
       * <code>optional bool prefer_suspend_clock_for_duration = 122;</code>
       * @return The preferSuspendClockForDuration.
       */
      @java.lang.Override
      public boolean getPreferSuspendClockForDuration() {
        return preferSuspendClockForDuration_;
      }
      /**
       * <pre>
       * If true, |trace_duration_ms| should count also time in suspend. This
       * is propagated from TraceConfig.prefer_suspend_clock_for_duration.
       * </pre>
       *
       * <code>optional bool prefer_suspend_clock_for_duration = 122;</code>
       * @param value The preferSuspendClockForDuration to set.
       * @return This builder for chaining.
       */
      public Builder setPreferSuspendClockForDuration(boolean value) {

        preferSuspendClockForDuration_ = value;
        bitField0_ |= 0x00000008;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If true, |trace_duration_ms| should count also time in suspend. This
       * is propagated from TraceConfig.prefer_suspend_clock_for_duration.
       * </pre>
       *
       * <code>optional bool prefer_suspend_clock_for_duration = 122;</code>
       * @return This builder for chaining.
       */
      public Builder clearPreferSuspendClockForDuration() {
        bitField0_ = (bitField0_ & ~0x00000008);
        preferSuspendClockForDuration_ = false;
        onChanged();
        return this;
      }

      private int stopTimeoutMs_ ;
      /**
       * <pre>
       * Set by the service to indicate how long it waits after StopDataSource.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint32 stop_timeout_ms = 7;</code>
       * @return Whether the stopTimeoutMs field is set.
       */
      @java.lang.Override
      public boolean hasStopTimeoutMs() {
        return ((bitField0_ & 0x00000010) != 0);
      }
      /**
       * <pre>
       * Set by the service to indicate how long it waits after StopDataSource.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint32 stop_timeout_ms = 7;</code>
       * @return The stopTimeoutMs.
       */
      @java.lang.Override
      public int getStopTimeoutMs() {
        return stopTimeoutMs_;
      }
      /**
       * <pre>
       * Set by the service to indicate how long it waits after StopDataSource.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint32 stop_timeout_ms = 7;</code>
       * @param value The stopTimeoutMs to set.
       * @return This builder for chaining.
       */
      public Builder setStopTimeoutMs(int value) {

        stopTimeoutMs_ = value;
        bitField0_ |= 0x00000010;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Set by the service to indicate how long it waits after StopDataSource.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint32 stop_timeout_ms = 7;</code>
       * @return This builder for chaining.
       */
      public Builder clearStopTimeoutMs() {
        bitField0_ = (bitField0_ & ~0x00000010);
        stopTimeoutMs_ = 0;
        onChanged();
        return this;
      }

      private boolean enableExtraGuardrails_ ;
      /**
       * <pre>
       * Set by the service to indicate whether this tracing session has extra
       * guardrails.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional bool enable_extra_guardrails = 6;</code>
       * @return Whether the enableExtraGuardrails field is set.
       */
      @java.lang.Override
      public boolean hasEnableExtraGuardrails() {
        return ((bitField0_ & 0x00000020) != 0);
      }
      /**
       * <pre>
       * Set by the service to indicate whether this tracing session has extra
       * guardrails.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional bool enable_extra_guardrails = 6;</code>
       * @return The enableExtraGuardrails.
       */
      @java.lang.Override
      public boolean getEnableExtraGuardrails() {
        return enableExtraGuardrails_;
      }
      /**
       * <pre>
       * Set by the service to indicate whether this tracing session has extra
       * guardrails.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional bool enable_extra_guardrails = 6;</code>
       * @param value The enableExtraGuardrails to set.
       * @return This builder for chaining.
       */
      public Builder setEnableExtraGuardrails(boolean value) {

        enableExtraGuardrails_ = value;
        bitField0_ |= 0x00000020;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Set by the service to indicate whether this tracing session has extra
       * guardrails.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional bool enable_extra_guardrails = 6;</code>
       * @return This builder for chaining.
       */
      public Builder clearEnableExtraGuardrails() {
        bitField0_ = (bitField0_ & ~0x00000020);
        enableExtraGuardrails_ = false;
        onChanged();
        return this;
      }

      private int sessionInitiator_ = 0;
      /**
       * <pre>
       * Set by the service to indicate which user initiated this trace.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional .perfetto.protos.DataSourceConfig.SessionInitiator session_initiator = 8;</code>
       * @return Whether the sessionInitiator field is set.
       */
      @java.lang.Override public boolean hasSessionInitiator() {
        return ((bitField0_ & 0x00000040) != 0);
      }
      /**
       * <pre>
       * Set by the service to indicate which user initiated this trace.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional .perfetto.protos.DataSourceConfig.SessionInitiator session_initiator = 8;</code>
       * @return The sessionInitiator.
       */
      @java.lang.Override
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator getSessionInitiator() {
        org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator result = org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator.forNumber(sessionInitiator_);
        return result == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator.SESSION_INITIATOR_UNSPECIFIED : result;
      }
      /**
       * <pre>
       * Set by the service to indicate which user initiated this trace.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional .perfetto.protos.DataSourceConfig.SessionInitiator session_initiator = 8;</code>
       * @param value The sessionInitiator to set.
       * @return This builder for chaining.
       */
      public Builder setSessionInitiator(org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig.SessionInitiator value) {
        if (value == null) {
          throw new NullPointerException();
        }
        bitField0_ |= 0x00000040;
        sessionInitiator_ = value.getNumber();
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Set by the service to indicate which user initiated this trace.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional .perfetto.protos.DataSourceConfig.SessionInitiator session_initiator = 8;</code>
       * @return This builder for chaining.
       */
      public Builder clearSessionInitiator() {
        bitField0_ = (bitField0_ & ~0x00000040);
        sessionInitiator_ = 0;
        onChanged();
        return this;
      }

      private long tracingSessionId_ ;
      /**
       * <pre>
       * Set by the service to indicate which tracing session the data source
       * belongs to. The intended use case for this is checking if two data sources,
       * one of which produces metadata for the other one, belong to the same trace
       * session and hence should be linked together.
       * This field was introduced in Aug 2018 after Android P.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint64 tracing_session_id = 4;</code>
       * @return Whether the tracingSessionId field is set.
       */
      @java.lang.Override
      public boolean hasTracingSessionId() {
        return ((bitField0_ & 0x00000080) != 0);
      }
      /**
       * <pre>
       * Set by the service to indicate which tracing session the data source
       * belongs to. The intended use case for this is checking if two data sources,
       * one of which produces metadata for the other one, belong to the same trace
       * session and hence should be linked together.
       * This field was introduced in Aug 2018 after Android P.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint64 tracing_session_id = 4;</code>
       * @return The tracingSessionId.
       */
      @java.lang.Override
      public long getTracingSessionId() {
        return tracingSessionId_;
      }
      /**
       * <pre>
       * Set by the service to indicate which tracing session the data source
       * belongs to. The intended use case for this is checking if two data sources,
       * one of which produces metadata for the other one, belong to the same trace
       * session and hence should be linked together.
       * This field was introduced in Aug 2018 after Android P.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint64 tracing_session_id = 4;</code>
       * @param value The tracingSessionId to set.
       * @return This builder for chaining.
       */
      public Builder setTracingSessionId(long value) {

        tracingSessionId_ = value;
        bitField0_ |= 0x00000080;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Set by the service to indicate which tracing session the data source
       * belongs to. The intended use case for this is checking if two data sources,
       * one of which produces metadata for the other one, belong to the same trace
       * session and hence should be linked together.
       * This field was introduced in Aug 2018 after Android P.
       * DO NOT SET in consumer as this will be overridden by the service.
       * </pre>
       *
       * <code>optional uint64 tracing_session_id = 4;</code>
       * @return This builder for chaining.
       */
      public Builder clearTracingSessionId() {
        bitField0_ = (bitField0_ & ~0x00000080);
        tracingSessionId_ = 0L;
        onChanged();
        return this;
      }

      private org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig gpuCounterConfig_;
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfigOrBuilder> gpuCounterConfigBuilder_;
      /**
       * <pre>
       * Data source name: gpu.counters
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
       * @return Whether the gpuCounterConfig field is set.
       */
      public boolean hasGpuCounterConfig() {
        return ((bitField0_ & 0x00000100) != 0);
      }
      /**
       * <pre>
       * Data source name: gpu.counters
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
       * @return The gpuCounterConfig.
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig getGpuCounterConfig() {
        if (gpuCounterConfigBuilder_ == null) {
          return gpuCounterConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig.getDefaultInstance() : gpuCounterConfig_;
        } else {
          return gpuCounterConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Data source name: gpu.counters
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
       */
      public Builder setGpuCounterConfig(org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig value) {
        if (gpuCounterConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          gpuCounterConfig_ = value;
        } else {
          gpuCounterConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: gpu.counters
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
       */
      public Builder setGpuCounterConfig(
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig.Builder builderForValue) {
        if (gpuCounterConfigBuilder_ == null) {
          gpuCounterConfig_ = builderForValue.build();
        } else {
          gpuCounterConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000100;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: gpu.counters
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
       */
      public Builder mergeGpuCounterConfig(org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig value) {
        if (gpuCounterConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000100) != 0) &&
            gpuCounterConfig_ != null &&
            gpuCounterConfig_ != org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig.getDefaultInstance()) {
            getGpuCounterConfigBuilder().mergeFrom(value);
          } else {
            gpuCounterConfig_ = value;
          }
        } else {
          gpuCounterConfigBuilder_.mergeFrom(value);
        }
        if (gpuCounterConfig_ != null) {
          bitField0_ |= 0x00000100;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Data source name: gpu.counters
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
       */
      public Builder clearGpuCounterConfig() {
        bitField0_ = (bitField0_ & ~0x00000100);
        gpuCounterConfig_ = null;
        if (gpuCounterConfigBuilder_ != null) {
          gpuCounterConfigBuilder_.dispose();
          gpuCounterConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: gpu.counters
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig.Builder getGpuCounterConfigBuilder() {
        bitField0_ |= 0x00000100;
        onChanged();
        return getGpuCounterConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Data source name: gpu.counters
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfigOrBuilder getGpuCounterConfigOrBuilder() {
        if (gpuCounterConfigBuilder_ != null) {
          return gpuCounterConfigBuilder_.getMessageOrBuilder();
        } else {
          return gpuCounterConfig_ == null ?
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig.getDefaultInstance() : gpuCounterConfig_;
        }
      }
      /**
       * <pre>
       * Data source name: gpu.counters
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuCounterConfig gpu_counter_config = 108 [lazy = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfigOrBuilder>
          getGpuCounterConfigFieldBuilder() {
        if (gpuCounterConfigBuilder_ == null) {
          gpuCounterConfigBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.GpuCounterConfigOrBuilder>(
                  getGpuCounterConfig(),
                  getParentForChildren(),
                  isClean());
          gpuCounterConfig_ = null;
        }
        return gpuCounterConfigBuilder_;
      }

      private org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig vulkanMemoryConfig_;
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfigOrBuilder> vulkanMemoryConfigBuilder_;
      /**
       * <pre>
       * Data source name: vulkan.memory_tracker
       * </pre>
       *
       * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
       * @return Whether the vulkanMemoryConfig field is set.
       */
      public boolean hasVulkanMemoryConfig() {
        return ((bitField0_ & 0x00000200) != 0);
      }
      /**
       * <pre>
       * Data source name: vulkan.memory_tracker
       * </pre>
       *
       * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
       * @return The vulkanMemoryConfig.
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig getVulkanMemoryConfig() {
        if (vulkanMemoryConfigBuilder_ == null) {
          return vulkanMemoryConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig.getDefaultInstance() : vulkanMemoryConfig_;
        } else {
          return vulkanMemoryConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Data source name: vulkan.memory_tracker
       * </pre>
       *
       * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
       */
      public Builder setVulkanMemoryConfig(org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig value) {
        if (vulkanMemoryConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          vulkanMemoryConfig_ = value;
        } else {
          vulkanMemoryConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: vulkan.memory_tracker
       * </pre>
       *
       * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
       */
      public Builder setVulkanMemoryConfig(
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig.Builder builderForValue) {
        if (vulkanMemoryConfigBuilder_ == null) {
          vulkanMemoryConfig_ = builderForValue.build();
        } else {
          vulkanMemoryConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000200;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: vulkan.memory_tracker
       * </pre>
       *
       * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
       */
      public Builder mergeVulkanMemoryConfig(org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig value) {
        if (vulkanMemoryConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000200) != 0) &&
            vulkanMemoryConfig_ != null &&
            vulkanMemoryConfig_ != org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig.getDefaultInstance()) {
            getVulkanMemoryConfigBuilder().mergeFrom(value);
          } else {
            vulkanMemoryConfig_ = value;
          }
        } else {
          vulkanMemoryConfigBuilder_.mergeFrom(value);
        }
        if (vulkanMemoryConfig_ != null) {
          bitField0_ |= 0x00000200;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Data source name: vulkan.memory_tracker
       * </pre>
       *
       * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
       */
      public Builder clearVulkanMemoryConfig() {
        bitField0_ = (bitField0_ & ~0x00000200);
        vulkanMemoryConfig_ = null;
        if (vulkanMemoryConfigBuilder_ != null) {
          vulkanMemoryConfigBuilder_.dispose();
          vulkanMemoryConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: vulkan.memory_tracker
       * </pre>
       *
       * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig.Builder getVulkanMemoryConfigBuilder() {
        bitField0_ |= 0x00000200;
        onChanged();
        return getVulkanMemoryConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Data source name: vulkan.memory_tracker
       * </pre>
       *
       * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfigOrBuilder getVulkanMemoryConfigOrBuilder() {
        if (vulkanMemoryConfigBuilder_ != null) {
          return vulkanMemoryConfigBuilder_.getMessageOrBuilder();
        } else {
          return vulkanMemoryConfig_ == null ?
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig.getDefaultInstance() : vulkanMemoryConfig_;
        }
      }
      /**
       * <pre>
       * Data source name: vulkan.memory_tracker
       * </pre>
       *
       * <code>optional .perfetto.protos.VulkanMemoryConfig vulkan_memory_config = 112 [lazy = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfigOrBuilder>
          getVulkanMemoryConfigFieldBuilder() {
        if (vulkanMemoryConfigBuilder_ == null) {
          vulkanMemoryConfigBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.VulkanMemoryConfigOrBuilder>(
                  getVulkanMemoryConfig(),
                  getParentForChildren(),
                  isClean());
          vulkanMemoryConfig_ = null;
        }
        return vulkanMemoryConfigBuilder_;
      }

      private org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig trackEventConfig_;
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfigOrBuilder> trackEventConfigBuilder_;
      /**
       * <pre>
       * Data source name: track_event
       * </pre>
       *
       * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
       * @return Whether the trackEventConfig field is set.
       */
      public boolean hasTrackEventConfig() {
        return ((bitField0_ & 0x00000400) != 0);
      }
      /**
       * <pre>
       * Data source name: track_event
       * </pre>
       *
       * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
       * @return The trackEventConfig.
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig getTrackEventConfig() {
        if (trackEventConfigBuilder_ == null) {
          return trackEventConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig.getDefaultInstance() : trackEventConfig_;
        } else {
          return trackEventConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Data source name: track_event
       * </pre>
       *
       * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
       */
      public Builder setTrackEventConfig(org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig value) {
        if (trackEventConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          trackEventConfig_ = value;
        } else {
          trackEventConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: track_event
       * </pre>
       *
       * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
       */
      public Builder setTrackEventConfig(
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig.Builder builderForValue) {
        if (trackEventConfigBuilder_ == null) {
          trackEventConfig_ = builderForValue.build();
        } else {
          trackEventConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000400;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: track_event
       * </pre>
       *
       * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
       */
      public Builder mergeTrackEventConfig(org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig value) {
        if (trackEventConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000400) != 0) &&
            trackEventConfig_ != null &&
            trackEventConfig_ != org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig.getDefaultInstance()) {
            getTrackEventConfigBuilder().mergeFrom(value);
          } else {
            trackEventConfig_ = value;
          }
        } else {
          trackEventConfigBuilder_.mergeFrom(value);
        }
        if (trackEventConfig_ != null) {
          bitField0_ |= 0x00000400;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Data source name: track_event
       * </pre>
       *
       * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
       */
      public Builder clearTrackEventConfig() {
        bitField0_ = (bitField0_ & ~0x00000400);
        trackEventConfig_ = null;
        if (trackEventConfigBuilder_ != null) {
          trackEventConfigBuilder_.dispose();
          trackEventConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: track_event
       * </pre>
       *
       * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig.Builder getTrackEventConfigBuilder() {
        bitField0_ |= 0x00000400;
        onChanged();
        return getTrackEventConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Data source name: track_event
       * </pre>
       *
       * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfigOrBuilder getTrackEventConfigOrBuilder() {
        if (trackEventConfigBuilder_ != null) {
          return trackEventConfigBuilder_.getMessageOrBuilder();
        } else {
          return trackEventConfig_ == null ?
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig.getDefaultInstance() : trackEventConfig_;
        }
      }
      /**
       * <pre>
       * Data source name: track_event
       * </pre>
       *
       * <code>optional .perfetto.protos.TrackEventConfig track_event_config = 113 [lazy = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfigOrBuilder>
          getTrackEventConfigFieldBuilder() {
        if (trackEventConfigBuilder_ == null) {
          trackEventConfigBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.TrackEventConfigOrBuilder>(
                  getTrackEventConfig(),
                  getParentForChildren(),
                  isClean());
          trackEventConfig_ = null;
        }
        return trackEventConfigBuilder_;
      }

      private org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig interceptorConfig_;
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfigOrBuilder> interceptorConfigBuilder_;
      /**
       * <pre>
       * If an interceptor is specified here, packets for this data source will be
       * rerouted to the interceptor instead of the main trace buffer. This can be
       * used, for example, to write trace data into ETW or for logging trace points
       * to the console.
       *
       * Note that interceptors are only supported by data sources registered
       * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
       * traced_probes) may not support interception.
       * </pre>
       *
       * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
       * @return Whether the interceptorConfig field is set.
       */
      public boolean hasInterceptorConfig() {
        return ((bitField0_ & 0x00000800) != 0);
      }
      /**
       * <pre>
       * If an interceptor is specified here, packets for this data source will be
       * rerouted to the interceptor instead of the main trace buffer. This can be
       * used, for example, to write trace data into ETW or for logging trace points
       * to the console.
       *
       * Note that interceptors are only supported by data sources registered
       * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
       * traced_probes) may not support interception.
       * </pre>
       *
       * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
       * @return The interceptorConfig.
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig getInterceptorConfig() {
        if (interceptorConfigBuilder_ == null) {
          return interceptorConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig.getDefaultInstance() : interceptorConfig_;
        } else {
          return interceptorConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * If an interceptor is specified here, packets for this data source will be
       * rerouted to the interceptor instead of the main trace buffer. This can be
       * used, for example, to write trace data into ETW or for logging trace points
       * to the console.
       *
       * Note that interceptors are only supported by data sources registered
       * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
       * traced_probes) may not support interception.
       * </pre>
       *
       * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
       */
      public Builder setInterceptorConfig(org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig value) {
        if (interceptorConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          interceptorConfig_ = value;
        } else {
          interceptorConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If an interceptor is specified here, packets for this data source will be
       * rerouted to the interceptor instead of the main trace buffer. This can be
       * used, for example, to write trace data into ETW or for logging trace points
       * to the console.
       *
       * Note that interceptors are only supported by data sources registered
       * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
       * traced_probes) may not support interception.
       * </pre>
       *
       * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
       */
      public Builder setInterceptorConfig(
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig.Builder builderForValue) {
        if (interceptorConfigBuilder_ == null) {
          interceptorConfig_ = builderForValue.build();
        } else {
          interceptorConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00000800;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If an interceptor is specified here, packets for this data source will be
       * rerouted to the interceptor instead of the main trace buffer. This can be
       * used, for example, to write trace data into ETW or for logging trace points
       * to the console.
       *
       * Note that interceptors are only supported by data sources registered
       * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
       * traced_probes) may not support interception.
       * </pre>
       *
       * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
       */
      public Builder mergeInterceptorConfig(org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig value) {
        if (interceptorConfigBuilder_ == null) {
          if (((bitField0_ & 0x00000800) != 0) &&
            interceptorConfig_ != null &&
            interceptorConfig_ != org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig.getDefaultInstance()) {
            getInterceptorConfigBuilder().mergeFrom(value);
          } else {
            interceptorConfig_ = value;
          }
        } else {
          interceptorConfigBuilder_.mergeFrom(value);
        }
        if (interceptorConfig_ != null) {
          bitField0_ |= 0x00000800;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * If an interceptor is specified here, packets for this data source will be
       * rerouted to the interceptor instead of the main trace buffer. This can be
       * used, for example, to write trace data into ETW or for logging trace points
       * to the console.
       *
       * Note that interceptors are only supported by data sources registered
       * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
       * traced_probes) may not support interception.
       * </pre>
       *
       * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
       */
      public Builder clearInterceptorConfig() {
        bitField0_ = (bitField0_ & ~0x00000800);
        interceptorConfig_ = null;
        if (interceptorConfigBuilder_ != null) {
          interceptorConfigBuilder_.dispose();
          interceptorConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * If an interceptor is specified here, packets for this data source will be
       * rerouted to the interceptor instead of the main trace buffer. This can be
       * used, for example, to write trace data into ETW or for logging trace points
       * to the console.
       *
       * Note that interceptors are only supported by data sources registered
       * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
       * traced_probes) may not support interception.
       * </pre>
       *
       * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig.Builder getInterceptorConfigBuilder() {
        bitField0_ |= 0x00000800;
        onChanged();
        return getInterceptorConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * If an interceptor is specified here, packets for this data source will be
       * rerouted to the interceptor instead of the main trace buffer. This can be
       * used, for example, to write trace data into ETW or for logging trace points
       * to the console.
       *
       * Note that interceptors are only supported by data sources registered
       * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
       * traced_probes) may not support interception.
       * </pre>
       *
       * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfigOrBuilder getInterceptorConfigOrBuilder() {
        if (interceptorConfigBuilder_ != null) {
          return interceptorConfigBuilder_.getMessageOrBuilder();
        } else {
          return interceptorConfig_ == null ?
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig.getDefaultInstance() : interceptorConfig_;
        }
      }
      /**
       * <pre>
       * If an interceptor is specified here, packets for this data source will be
       * rerouted to the interceptor instead of the main trace buffer. This can be
       * used, for example, to write trace data into ETW or for logging trace points
       * to the console.
       *
       * Note that interceptors are only supported by data sources registered
       * through the Perfetto SDK API. Data sources that don't use that API (e.g.,
       * traced_probes) may not support interception.
       * </pre>
       *
       * <code>optional .perfetto.protos.InterceptorConfig interceptor_config = 115;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfigOrBuilder>
          getInterceptorConfigFieldBuilder() {
        if (interceptorConfigBuilder_ == null) {
          interceptorConfigBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.InterceptorConfigOrBuilder>(
                  getInterceptorConfig(),
                  getParentForChildren(),
                  isClean());
          interceptorConfig_ = null;
        }
        return interceptorConfigBuilder_;
      }

      private org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig gpuRenderstagesConfig_;
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfigOrBuilder> gpuRenderstagesConfigBuilder_;
      /**
       * <pre>
       * Data source name: gpu.renderstages
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
       * @return Whether the gpuRenderstagesConfig field is set.
       */
      public boolean hasGpuRenderstagesConfig() {
        return ((bitField0_ & 0x00001000) != 0);
      }
      /**
       * <pre>
       * Data source name: gpu.renderstages
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
       * @return The gpuRenderstagesConfig.
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig getGpuRenderstagesConfig() {
        if (gpuRenderstagesConfigBuilder_ == null) {
          return gpuRenderstagesConfig_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig.getDefaultInstance() : gpuRenderstagesConfig_;
        } else {
          return gpuRenderstagesConfigBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * Data source name: gpu.renderstages
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
       */
      public Builder setGpuRenderstagesConfig(org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig value) {
        if (gpuRenderstagesConfigBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          gpuRenderstagesConfig_ = value;
        } else {
          gpuRenderstagesConfigBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: gpu.renderstages
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
       */
      public Builder setGpuRenderstagesConfig(
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig.Builder builderForValue) {
        if (gpuRenderstagesConfigBuilder_ == null) {
          gpuRenderstagesConfig_ = builderForValue.build();
        } else {
          gpuRenderstagesConfigBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00001000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: gpu.renderstages
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
       */
      public Builder mergeGpuRenderstagesConfig(org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig value) {
        if (gpuRenderstagesConfigBuilder_ == null) {
          if (((bitField0_ & 0x00001000) != 0) &&
            gpuRenderstagesConfig_ != null &&
            gpuRenderstagesConfig_ != org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig.getDefaultInstance()) {
            getGpuRenderstagesConfigBuilder().mergeFrom(value);
          } else {
            gpuRenderstagesConfig_ = value;
          }
        } else {
          gpuRenderstagesConfigBuilder_.mergeFrom(value);
        }
        if (gpuRenderstagesConfig_ != null) {
          bitField0_ |= 0x00001000;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * Data source name: gpu.renderstages
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
       */
      public Builder clearGpuRenderstagesConfig() {
        bitField0_ = (bitField0_ & ~0x00001000);
        gpuRenderstagesConfig_ = null;
        if (gpuRenderstagesConfigBuilder_ != null) {
          gpuRenderstagesConfigBuilder_.dispose();
          gpuRenderstagesConfigBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * Data source name: gpu.renderstages
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig.Builder getGpuRenderstagesConfigBuilder() {
        bitField0_ |= 0x00001000;
        onChanged();
        return getGpuRenderstagesConfigFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * Data source name: gpu.renderstages
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfigOrBuilder getGpuRenderstagesConfigOrBuilder() {
        if (gpuRenderstagesConfigBuilder_ != null) {
          return gpuRenderstagesConfigBuilder_.getMessageOrBuilder();
        } else {
          return gpuRenderstagesConfig_ == null ?
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig.getDefaultInstance() : gpuRenderstagesConfig_;
        }
      }
      /**
       * <pre>
       * Data source name: gpu.renderstages
       * </pre>
       *
       * <code>optional .perfetto.protos.GpuRenderStagesConfig gpu_renderstages_config = 133 [lazy = true];</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfigOrBuilder>
          getGpuRenderstagesConfigFieldBuilder() {
        if (gpuRenderstagesConfigBuilder_ == null) {
          gpuRenderstagesConfigBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.GpuRenderStagesConfigOrBuilder>(
                  getGpuRenderstagesConfig(),
                  getParentForChildren(),
                  isClean());
          gpuRenderstagesConfig_ = null;
        }
        return gpuRenderstagesConfigBuilder_;
      }

      private java.lang.Object legacyConfig_ = "";
      /**
       * <pre>
       * This is a fallback mechanism to send a free-form text config to the
       * producer. In theory this should never be needed. All the code that
       * is part of the platform (i.e. traced service) is supposed to *not* truncate
       * the trace config proto and propagate unknown fields. However, if anything
       * in the pipeline (client or backend) ends up breaking this forward compat
       * plan, this field will become the escape hatch to allow future data sources
       * to get some meaningful configuration.
       * </pre>
       *
       * <code>optional string legacy_config = 1000;</code>
       * @return Whether the legacyConfig field is set.
       */
      public boolean hasLegacyConfig() {
        return ((bitField0_ & 0x00002000) != 0);
      }
      /**
       * <pre>
       * This is a fallback mechanism to send a free-form text config to the
       * producer. In theory this should never be needed. All the code that
       * is part of the platform (i.e. traced service) is supposed to *not* truncate
       * the trace config proto and propagate unknown fields. However, if anything
       * in the pipeline (client or backend) ends up breaking this forward compat
       * plan, this field will become the escape hatch to allow future data sources
       * to get some meaningful configuration.
       * </pre>
       *
       * <code>optional string legacy_config = 1000;</code>
       * @return The legacyConfig.
       */
      public java.lang.String getLegacyConfig() {
        java.lang.Object ref = legacyConfig_;
        if (!(ref instanceof java.lang.String)) {
          com.google.protobuf.ByteString bs =
              (com.google.protobuf.ByteString) ref;
          java.lang.String s = bs.toStringUtf8();
          if (bs.isValidUtf8()) {
            legacyConfig_ = s;
          }
          return s;
        } else {
          return (java.lang.String) ref;
        }
      }
      /**
       * <pre>
       * This is a fallback mechanism to send a free-form text config to the
       * producer. In theory this should never be needed. All the code that
       * is part of the platform (i.e. traced service) is supposed to *not* truncate
       * the trace config proto and propagate unknown fields. However, if anything
       * in the pipeline (client or backend) ends up breaking this forward compat
       * plan, this field will become the escape hatch to allow future data sources
       * to get some meaningful configuration.
       * </pre>
       *
       * <code>optional string legacy_config = 1000;</code>
       * @return The bytes for legacyConfig.
       */
      public com.google.protobuf.ByteString
          getLegacyConfigBytes() {
        java.lang.Object ref = legacyConfig_;
        if (ref instanceof String) {
          com.google.protobuf.ByteString b =
              com.google.protobuf.ByteString.copyFromUtf8(
                  (java.lang.String) ref);
          legacyConfig_ = b;
          return b;
        } else {
          return (com.google.protobuf.ByteString) ref;
        }
      }
      /**
       * <pre>
       * This is a fallback mechanism to send a free-form text config to the
       * producer. In theory this should never be needed. All the code that
       * is part of the platform (i.e. traced service) is supposed to *not* truncate
       * the trace config proto and propagate unknown fields. However, if anything
       * in the pipeline (client or backend) ends up breaking this forward compat
       * plan, this field will become the escape hatch to allow future data sources
       * to get some meaningful configuration.
       * </pre>
       *
       * <code>optional string legacy_config = 1000;</code>
       * @param value The legacyConfig to set.
       * @return This builder for chaining.
       */
      public Builder setLegacyConfig(
          java.lang.String value) {
        if (value == null) { throw new NullPointerException(); }
        legacyConfig_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is a fallback mechanism to send a free-form text config to the
       * producer. In theory this should never be needed. All the code that
       * is part of the platform (i.e. traced service) is supposed to *not* truncate
       * the trace config proto and propagate unknown fields. However, if anything
       * in the pipeline (client or backend) ends up breaking this forward compat
       * plan, this field will become the escape hatch to allow future data sources
       * to get some meaningful configuration.
       * </pre>
       *
       * <code>optional string legacy_config = 1000;</code>
       * @return This builder for chaining.
       */
      public Builder clearLegacyConfig() {
        legacyConfig_ = getDefaultInstance().getLegacyConfig();
        bitField0_ = (bitField0_ & ~0x00002000);
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This is a fallback mechanism to send a free-form text config to the
       * producer. In theory this should never be needed. All the code that
       * is part of the platform (i.e. traced service) is supposed to *not* truncate
       * the trace config proto and propagate unknown fields. However, if anything
       * in the pipeline (client or backend) ends up breaking this forward compat
       * plan, this field will become the escape hatch to allow future data sources
       * to get some meaningful configuration.
       * </pre>
       *
       * <code>optional string legacy_config = 1000;</code>
       * @param value The bytes for legacyConfig to set.
       * @return This builder for chaining.
       */
      public Builder setLegacyConfigBytes(
          com.google.protobuf.ByteString value) {
        if (value == null) { throw new NullPointerException(); }
        legacyConfig_ = value;
        bitField0_ |= 0x00002000;
        onChanged();
        return this;
      }

      private org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig forTesting_;
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfigOrBuilder> forTestingBuilder_;
      /**
       * <pre>
       * This field is only used for testing.
       * </pre>
       *
       * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
       * @return Whether the forTesting field is set.
       */
      public boolean hasForTesting() {
        return ((bitField0_ & 0x00004000) != 0);
      }
      /**
       * <pre>
       * This field is only used for testing.
       * </pre>
       *
       * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
       * @return The forTesting.
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig getForTesting() {
        if (forTestingBuilder_ == null) {
          return forTesting_ == null ? org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig.getDefaultInstance() : forTesting_;
        } else {
          return forTestingBuilder_.getMessage();
        }
      }
      /**
       * <pre>
       * This field is only used for testing.
       * </pre>
       *
       * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
       */
      public Builder setForTesting(org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig value) {
        if (forTestingBuilder_ == null) {
          if (value == null) {
            throw new NullPointerException();
          }
          forTesting_ = value;
        } else {
          forTestingBuilder_.setMessage(value);
        }
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field is only used for testing.
       * </pre>
       *
       * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
       */
      public Builder setForTesting(
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig.Builder builderForValue) {
        if (forTestingBuilder_ == null) {
          forTesting_ = builderForValue.build();
        } else {
          forTestingBuilder_.setMessage(builderForValue.build());
        }
        bitField0_ |= 0x00004000;
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field is only used for testing.
       * </pre>
       *
       * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
       */
      public Builder mergeForTesting(org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig value) {
        if (forTestingBuilder_ == null) {
          if (((bitField0_ & 0x00004000) != 0) &&
            forTesting_ != null &&
            forTesting_ != org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig.getDefaultInstance()) {
            getForTestingBuilder().mergeFrom(value);
          } else {
            forTesting_ = value;
          }
        } else {
          forTestingBuilder_.mergeFrom(value);
        }
        if (forTesting_ != null) {
          bitField0_ |= 0x00004000;
          onChanged();
        }
        return this;
      }
      /**
       * <pre>
       * This field is only used for testing.
       * </pre>
       *
       * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
       */
      public Builder clearForTesting() {
        bitField0_ = (bitField0_ & ~0x00004000);
        forTesting_ = null;
        if (forTestingBuilder_ != null) {
          forTestingBuilder_.dispose();
          forTestingBuilder_ = null;
        }
        onChanged();
        return this;
      }
      /**
       * <pre>
       * This field is only used for testing.
       * </pre>
       *
       * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig.Builder getForTestingBuilder() {
        bitField0_ |= 0x00004000;
        onChanged();
        return getForTestingFieldBuilder().getBuilder();
      }
      /**
       * <pre>
       * This field is only used for testing.
       * </pre>
       *
       * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
       */
      public org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfigOrBuilder getForTestingOrBuilder() {
        if (forTestingBuilder_ != null) {
          return forTestingBuilder_.getMessageOrBuilder();
        } else {
          return forTesting_ == null ?
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig.getDefaultInstance() : forTesting_;
        }
      }
      /**
       * <pre>
       * This field is only used for testing.
       * </pre>
       *
       * <code>optional .perfetto.protos.TestConfig for_testing = 1001;</code>
       */
      private com.google.protobuf.SingleFieldBuilder<
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfigOrBuilder>
          getForTestingFieldBuilder() {
        if (forTestingBuilder_ == null) {
          forTestingBuilder_ = new com.google.protobuf.SingleFieldBuilder<
              org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfig.Builder, org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.TestConfigOrBuilder>(
                  getForTesting(),
                  getParentForChildren(),
                  isClean());
          forTesting_ = null;
        }
        return forTestingBuilder_;
      }

      // @@protoc_insertion_point(builder_scope:perfetto.protos.DataSourceConfig)
    }

    // @@protoc_insertion_point(class_scope:perfetto.protos.DataSourceConfig)
    private static final org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig DEFAULT_INSTANCE;
    static {
      DEFAULT_INSTANCE = new org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig();
    }

    public static org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig getDefaultInstance() {
      return DEFAULT_INSTANCE;
    }

    private static final com.google.protobuf.Parser<DataSourceConfig>
        PARSER = new com.google.protobuf.AbstractParser<DataSourceConfig>() {
      @java.lang.Override
      public DataSourceConfig parsePartialFrom(
          com.google.protobuf.CodedInputStream input,
          com.google.protobuf.ExtensionRegistryLite extensionRegistry)
          throws com.google.protobuf.InvalidProtocolBufferException {
        Builder builder = newBuilder();
        try {
          builder.mergeFrom(input, extensionRegistry);
        } catch (com.google.protobuf.InvalidProtocolBufferException e) {
          throw e.setUnfinishedMessage(builder.buildPartial());
        } catch (com.google.protobuf.UninitializedMessageException e) {
          throw e.asInvalidProtocolBufferException().setUnfinishedMessage(builder.buildPartial());
        } catch (java.io.IOException e) {
          throw new com.google.protobuf.InvalidProtocolBufferException(e)
              .setUnfinishedMessage(builder.buildPartial());
        }
        return builder.buildPartial();
      }
    };

    public static com.google.protobuf.Parser<DataSourceConfig> parser() {
      return PARSER;
    }

    @java.lang.Override
    public com.google.protobuf.Parser<DataSourceConfig> getParserForType() {
      return PARSER;
    }

    @java.lang.Override
    public org.eclipse.tracecompass.incubator.internal.perfetto.protos.DataSourceConfigOuterClass.DataSourceConfig getDefaultInstanceForType() {
      return DEFAULT_INSTANCE;
    }

  }

  private static final com.google.protobuf.Descriptors.Descriptor
    internal_static_perfetto_protos_DataSourceConfig_descriptor;
  private static final
    com.google.protobuf.GeneratedMessage.FieldAccessorTable
      internal_static_perfetto_protos_DataSourceConfig_fieldAccessorTable;

  public static com.google.protobuf.Descriptors.FileDescriptor
      getDescriptor() {
    return descriptor;
  }
  private static  com.google.protobuf.Descriptors.FileDescriptor
      descriptor;
  static {
    java.lang.String[] descriptorData = {
      "\n/protos/perfetto/config/data_source_con" +
      "fig.proto\022\017perfetto.protos\0323protos/perfe" +
      "tto/config/gpu/gpu_counter_config.proto\032" +
      "5protos/perfetto/config/gpu/vulkan_memor" +
      "y_config.proto\0328protos/perfetto/config/g" +
      "pu/gpu_renderstages_config.proto\032/protos" +
      "/perfetto/config/interceptor_config.prot" +
      "o\0327protos/perfetto/config/profiling/heap" +
      "profd_config.proto\0328protos/perfetto/conf" +
      "ig/profiling/java_hprof_config.proto\0328pr" +
      "otos/perfetto/config/profiling/perf_even" +
      "t_config.proto\032(protos/perfetto/config/t" +
      "est_config.proto\032;protos/perfetto/config" +
      "/track_event/track_event_config.proto\"\262\006" +
      "\n\020DataSourceConfig\022\014\n\004name\030\001 \001(\t\022\025\n\rtarg" +
      "et_buffer\030\002 \001(\r\022\031\n\021trace_duration_ms\030\003 \001" +
      "(\r\022)\n!prefer_suspend_clock_for_duration\030" +
      "z \001(\010\022\027\n\017stop_timeout_ms\030\007 \001(\r\022\037\n\027enable" +
      "_extra_guardrails\030\006 \001(\010\022M\n\021session_initi" +
      "ator\030\010 \001(\01622.perfetto.protos.DataSourceC" +
      "onfig.SessionInitiator\022\032\n\022tracing_sessio" +
      "n_id\030\004 \001(\004\022A\n\022gpu_counter_config\030l \001(\0132!" +
      ".perfetto.protos.GpuCounterConfigB\002(\001\022E\n" +
      "\024vulkan_memory_config\030p \001(\0132#.perfetto.p" +
      "rotos.VulkanMemoryConfigB\002(\001\022A\n\022track_ev" +
      "ent_config\030q \001(\0132!.perfetto.protos.Track" +
      "EventConfigB\002(\001\022>\n\022interceptor_config\030s " +
      "\001(\0132\".perfetto.protos.InterceptorConfig\022" +
      "L\n\027gpu_renderstages_config\030\205\001 \001(\0132&.perf" +
      "etto.protos.GpuRenderStagesConfigB\002(\001\022\026\n" +
      "\rlegacy_config\030\350\007 \001(\t\0221\n\013for_testing\030\351\007 " +
      "\001(\0132\033.perfetto.protos.TestConfig\"[\n\020Sess" +
      "ionInitiator\022!\n\035SESSION_INITIATOR_UNSPEC" +
      "IFIED\020\000\022$\n SESSION_INITIATOR_TRUSTED_SYS" +
      "TEM\020\001J\013\010\377\377\377\177\020\200\200\200\200\001"
    };
    descriptor = com.google.protobuf.Descriptors.FileDescriptor
      .internalBuildGeneratedFileFrom(descriptorData,
        new com.google.protobuf.Descriptors.FileDescriptor[] {
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.getDescriptor(),
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.getDescriptor(),
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.getDescriptor(),
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.getDescriptor(),
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.HeapprofdConfigOuterClass.getDescriptor(),
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.JavaHprofConfigOuterClass.getDescriptor(),
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.PerfEventConfigOuterClass.getDescriptor(),
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.getDescriptor(),
          org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.getDescriptor(),
        });
    internal_static_perfetto_protos_DataSourceConfig_descriptor =
      getDescriptor().getMessageTypes().get(0);
    internal_static_perfetto_protos_DataSourceConfig_fieldAccessorTable = new
      com.google.protobuf.GeneratedMessage.FieldAccessorTable(
        internal_static_perfetto_protos_DataSourceConfig_descriptor,
        new java.lang.String[] { "Name", "TargetBuffer", "TraceDurationMs", "PreferSuspendClockForDuration", "StopTimeoutMs", "EnableExtraGuardrails", "SessionInitiator", "TracingSessionId", "GpuCounterConfig", "VulkanMemoryConfig", "TrackEventConfig", "InterceptorConfig", "GpuRenderstagesConfig", "LegacyConfig", "ForTesting", });
    descriptor.resolveAllFeaturesImmutable();
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuCounterConfigOuterClass.getDescriptor();
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.VulkanMemoryConfigOuterClass.getDescriptor();
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.GpuRenderstagesConfig.getDescriptor();
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.InterceptorConfigOuterClass.getDescriptor();
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.HeapprofdConfigOuterClass.getDescriptor();
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.JavaHprofConfigOuterClass.getDescriptor();
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.PerfEventConfigOuterClass.getDescriptor();
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.TestConfigOuterClass.getDescriptor();
    org.eclipse.tracecompass.incubator.internal.perfetto.protos.TrackEventConfigOuterClass.getDescriptor();
  }

  // @@protoc_insertion_point(outer_class_scope)
}
